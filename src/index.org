#+TITLE: Dataservice
#+Author: VLEAD
#+Date: [2015-08-13 Thu]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org

* Introduction
  Dataservice is a micro service that allows persistence of data by other micro
  services over HTTP using REST API.  dataservie hides the implementation
  details of the data store that is required for data persistence.

* Requirements
  1. The model of the data on whose foundation dataservice is built is
     explicitly laid out. <<req1>>
  2. Python API is provided as a wrapper to make CRUD operations on the data.
  3. REST API is provided for various applications to perform CRUD operations
     on the data.

* Design & Implementation
** Python
*** __init__
#+BEGIN_SRC python :tangle src/__init__.py :eval no
print "src package"
import db

#+END_SRC
*** imports
#+BEGIN_SRC python :tangle src/db.py :eval no
# -*- coding: utf-8 -*-

from flask.ext.sqlalchemy import SQLAlchemy
from flask import current_app

import re

from ds_exceptions import AttributeRequired

db = SQLAlchemy()


# Abstract class to hold common methods
class Entity(db.Model):

    __abstract__ = True

    # save a db.Model to the database. commit it.
    def save(self):
        db.session.add(self)
        db.session.commit()

    # update the object, and commit to the database
    def update(self, **kwargs):
        for attr, val in kwargs.iteritems():
            self.__setattr__(attr, val)

        self.save()

#+END_SRC

** Data Model
   Description of the data model.

*** Types & Functions: List of all the types and functions in the model

**** Name

     Name is an alphabetical string.
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Name(object):
    def __init__(self, value):
        # if the string contains any non-alphabet and non-space character, raise
        # a type error
        if re.search('[^a-zA-Z ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC
**** Email

     Email is a type as defined in RFC 5321, 5322 and 6531.
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Email(object):
    def __init__(self, value):
        if not re.search('[^@]+@[^@]+\.[^@]+', value):
            raise TypeError('%s is not an email_id!' % value)
        self.value = value
#+END_SRC
**** URL

   URL is a type as defined in RFC 1738.

#+BEGIN_SRC python :tangle src/db.py :eval no
class URL(object):
    pass
#+END_SRC
**** Version

   Version is an alphanumeric string including '-' and '.'.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Version(object):
    pass
#+END_SRC
     
**** LabId

     LabId is a natural number.

**** TechnologyId

     TechnologyId is a natural number.

**** InstituteId

     InstituteId is a natural number.

**** InstituteName
    
     InstituteName is an alphabetical string including a '-'.
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class InstituteName(object):
    def __init__(self, value):
        # if the string contains any non-alphabet, non-hyphen and non-space
        # character, raise a type error
        if re.search('[^a-zA-Z\- ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC

**** DisciplineId

     DisciplineId is a natural number.

**** DeveloperId
     
     DeveloperId is a natural number.

**** ExperimentId

     ExperimentId is a natural number.

**** IntegrationLevel
      
   IntegrationLevel is {L0, L1, L2, L3, L4, L5, L6}.

#+BEGIN_SRC python :tangle src/db.py :eval no 
class IntegrationLevel(Entity):
    __tablename__ = 'integration_levels'
    id = db.Column(db.Integer, primary_key=True)
    level = db.Column(db.Integer, nullable=False)

    labs = db.relationship('Lab', backref='integration_level')
#+END_SRC
**** HostingPlatform

     HostingPlatform is {IIIT, Badal, AWS, Else}.

#+BEGIN_SRC python :tangle src/db.py :eval no 
class HostingPlatform(Entity):
    __tablename__ = 'hosting_platforms'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(32), nullable=False)

    labs = db.relationship('Lab', backref='hosted_on')
#+END_SRC
**** TypeOfLab

   TypeOfLab is { Simulation,
                 Remote Triggered,
                 Simulation and Remote Triggered,
                 Pilot Phase }

#+BEGIN_SRC python :tangle src/db.py :eval no
class TypeOfLab(Entity):
    __tablename__ = 'type_of_labs'
    id = db.Column(db.Integer, primary_key=True)
    type = db.Column(db.String(64), nullable=False)

    labs = db.relationship('Lab', backref='type_of_lab')
#+END_SRC
**** Developer
***** Immutable Data
      This is the data associated with Developer type, which is immutable.
      + DeveloperId
***** Mutable Data
      This is the data associated with Developer type, which is mutable.
      + Name
      + Email
      + Institute Id

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Developer(Entity):

    __tablename__ = 'developers'

    id = db.Column(db.Integer, primary_key=True)

    email_id = db.Column(db.String(128))
    name = db.Column(db.String(64), nullable=False)
    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))

    def __init__(self, **kwargs):
        keys = kwargs.keys()
        if name not in keys:
            raise AttributeRequired("name not passed to the constructor")
            
            
#+END_SRC

***** Functions that operate on the Developer domain
****** getId: Developer --> DeveloperId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

****** getName: Developer --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

****** getAllDevelopers: Nil --> set[Developer]
#+BEGIN_SRC 
    @staticmethod
    def get_developer(id):
        return Developer.query.get(id)
#+END_SRC

****** getLabs: Developer --> set[Lab]
#+BEGIN_SRC 

#+END_SRC

****** getInstitute: Developer --> Institute
#+BEGIN_SRC 

#+END_SRC

****** getDeveloper: DeveloperId --> Developer
#+BEGIN_SRC 
    def get_developer(id):
        return Developer.query.get(id)
#+END_SRC

****** getEmail: Developer --> Email
#+BEGIN_SRC 
    def get_email(self):
        return self.email_id
#+END_SRC

****** setName: Developer, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC

****** setEmail: Developer, Email --> Void
#+BEGIN_SRC 
    @typecheck(email_id=Email)
    def set_email(self, email_id):
        self.email_id = email_id.value
#+END_SRC

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'email_id': self.email_id,
            'name': self.name,
            'institute': self.institute.to_client()
        }
#+END_SRC

**** Institute

***** Immutable Data
This is the data associated with Institute type, which is immutable.

+ InstituteId
+ Mnemonic

***** Mutable Data

These are the data associated with Institute type, which are mutable

+ PIC
+ IIC

***** Mnemonic assigned to each institute
|---------------------------------+----------|
| Name                            | Mnemonic |
|---------------------------------+----------|
| IIIT Hyderabad                  | iiith    |
| IIT Bombay                      | iitb     |
| IIT Delhi                       | iitd     |
| IIT Roorkee                     | iitrrk   |
| IIT Guwahati                    | iitg     |
| IIT Kanpur                      | iitk     |
| IIT Kharagpur                   | iitkgp   |
| IIT Madras                      | iitm     |
| NIT Surathkal                   | nitk     |
| Amrita University               | amrita   |
| College of Engineering, Pune    | coep     |
| Dayalbagh Educational Institute | dei      |
|---------------------------------+----------|

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Institute(Entity):

    __tablename__ = 'institutes'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    pic = db.Column(db.String(128))
    iic = db.Column(db.String(128))

    labs = db.relationship('Lab', backref='institute')
    developers = db.relationship('Developer', backref='institute')
#+END_SRC

***** Functions that operate on Institute domain

****** getId: Institute --> InstituteId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

****** getName: Institute --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

****** getInstitute: InstituteId --> Institute
#+BEGIN_SRC 
    @staticmethod
    def get_institute_by_id(id):
        return Institute.query.get(id)
#+END_SRC

****** getMnemonic: Institute --> Mnemonic
#+BEGIN_SRC 
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

****** getInstitute: Mnemonic --> Institute
#+BEGIN_SRC 

#+END_SRC

****** getPIC: Institute --> Name
#+BEGIN_SRC 
    def get_pic(self):
        return self.pic
#+END_SRC
      
****** getIIC: Institute --> Name
#+BEGIN_SRC 
    def get_iic(self):
        return self.iic
#+END_SRC

****** getLabs: Institute --> set[Lab]
#+BEGIN_SRC 
    def get_labs(self):
        return self.labs
#+END_SRC

****** getDevelopers: Institute --> set[Developer]
#+BEGIN_SRC 
    def get_developers(self):
        return self.developers
#+END_SRC

****** getAllInstitutes: Nil --> set[Institute]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Institute.query.all()]
#+END_SRC

****** setPIC: Institute, Name --> Void
#+BEGIN_SRC 
    @typecheck(pic=Name)
    def set_pic(self, pic):
        self.pic = pic.value
#+END_SRC

****** setIIC: Institute, Name --> Void
#+BEGIN_SRC 
    @typecheck(iic=Name)
    def set_iic(self, iic):
        self.iic = iic.value
#+END_SRC
      
****** setName: Institute, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=InstituteName)
    def set_name(self, name):
        self.name = name.value
#+END_SRC

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'mnemonic': self.mnemonic,
            'pic': self.pic,
            'iic': self.iic
        }
#+END_SRC
**** Discipline

***** Immutable Data
This is the data associated with Discipline type, which is immutable.

+ DisciplineId
+ Mnemonic

***** Mutable Data
This is the data associated with Discipline type, which is mutable.

+ DNC

***** Mnemonic assigned to each discipline
|------------------------------------------+-----------|
| Name                                     | Mnemonic  |
|------------------------------------------+-----------|
| Aerospace Engineering                    | aero      |
| Biotechnology and Biomedical Engineering | biotech   |
| Chemical Engineering                     | chem-engg |
| Chemical Sciences                        | chem      |
| Civil Engineering                        | civil     |
| Computer Science and Engineering         | cse       |
| Electrical Engineering                   | ee        |
| Electronics and Communication            | ece       |
| Humanities                               | human     |
| Mechanical Engineering                   | mech      |
| Physical Sciences                        | phy-sc    |
| Textile Engineering                      | tex-engg  |
| Design Engineering                       | dsgn-engg |
| Material Sciences                        | mat-sc    |
|------------------------------------------+-----------|

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Discipline(Entity):

    __tablename__ = 'disciplines'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    dnc = db.Column(db.String(64))

    labs = db.relationship('Lab', backref='discipline')
#+END_SRC


***** Functions that operate on Discipline domain
****** getAllDisciplines: Nil --> set[Discipline]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Discipline.query.all()]
#+END_SRC

****** getId: Discipline --> DisciplineId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

****** getName: Discipline --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC
****** getDiscipline: DisciplineId --> Discipline
#+BEGIN_SRC 
    def get_discipline_by_id(id):
        return Discipline.query.get(id)
#+END_SRC

****** getMnemonic: Discipline --> Mnemonic
#+BEGIN_SRC 
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

****** getDiscipline: Mnemonic --> Discipline
#+BEGIN_SRC 

#+END_SRC

****** getLabs: Discipline --> set[Lab]
#+BEGIN_SRC 
    def get_labs(self):
        return self.labs
#+END_SRC

****** getDNC: Discipline --> Name
#+BEGIN_SRC 
    def get_dnc(self):
        return self.dnc
#+END_SRC

****** setName: Discipline --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC

****** setDNC: Discipline, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC      

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'mnemonic': self.mnemonic,
            'dnc': self.dnc
        }
#+END_SRC
**** Technology

***** Immutable Data
This is the data associated with Technology type, which is immutable.

+ TechnologyId

***** Mutable Data
These are the data associated with Technoloy type, which are mutable.

+ Version
+ FOSS

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Technology(Entity):

    __tablename__ = 'technologies'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    version = db.Column(db.String(32))
    foss = db.Column(db.Boolean)
#+END_SRC

***** Functions that operate on the Technology domain
****** getId: Technology --> TechnologyId

****** getAllTechnologies: Nil --> set[Technology]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Technology.query.all()]
#+END_SRC

****** getLabs: Technology --> set[Lab]
#+BEGIN_SRC 

#+END_SRC

****** getTechnology: TechnologyId --> Technology

****** getVersion: Technology --> Version

****** isFOSS: Technology --> Boolean

****** setVersion: Technology, Version --> Void

****** setFOSS: Technology, Boolean --> Void

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'version': self.version,
            'foss': self.foss
        }
#+END_SRC
**** Experiment

***** Immutable Data
      This is the data associated with Experiment type, which is immutable.

      + ExperimentId

***** Mutable Data
      These are the data associated with Discipline type, which are mutable.

      + ContentURL
      + SimulationURL
      + ContentHostedOn
      + SimulationHostedOn

***** Association
#+BEGIN_SRC python :tangle src/db.py :eval no
# association table of technologies and experiments                              
technologies_used_expt = db.Table(                                               
    'technologies_used_expt',                                                    
    db.Column('expt_id', db.Integer, db.ForeignKey('experiments.id')),           
    db.Column('tech_id', db.Integer, db.ForeignKey('technologies.id'))           
) 
#+END_SRC
***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Experiment(Entity):

    __tablename__ = 'experiments'

    id = db.Column(db.Integer, primary_key=True)

    # Our data set has really, really long experiment names and URLs!!
    name = db.Column(db.String(256))

    lab_id = db.Column(db.Integer, db.ForeignKey('labs.id'))

    content_url = db.Column(db.String(256))
    # content_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    content_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    content_on = db.relationship('HostingPlatform',
                                 foreign_keys=[content_on_id])

    simulation_url = db.Column(db.String(256))
    # simulation_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    simulation_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    simulation_on = db.relationship('HostingPlatform',
                                    foreign_keys=[simulation_on_id])

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_expt,
                                   backref='experiments')
#+END_SRC

Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        # TODO: implement the constructor and check the validity!
        pass
#+END_SRC

***** Functions that operate on the Experiment domain

****** getId: Experiment --> ExperimentId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

****** getExperiment: ExperimentId --> Experiment
#+BEGIN_SRC 
    @staticmethod
    def get_experiment(id):
        return Experiment.query.get(id)
#+END_SRC

****** getContentURL: Experiment --> URL + Nil
#+BEGIN_SRC 
    def get_content_url(self):
        return self.content_url
#+END_SRC

****** getSimulationURL: Experiment --> URL + Nil
#+BEGIN_SRC 
    def get_simulation_url(self):
        return self.simulation_url
#+END_SRC

****** getTechnologies: Experiment --> set[Technology]
#+BEGIN_SRC 

#+END_SRC

****** contentHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC 
    def content_hosted_on(self):
        return self.content_hosted_on
#+END_SRC

****** simulationHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC 
    def simulation_hosted_on(self):
        return self.simulation_hosted_on
#+END_SRC

****** getLab: Experiment --> Lab
#+BEGIN_SRC 
    def get_lab(self):
        return self.lab
#+END_SRC

****** setContentURL: Experiment, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_content_url(self, url):
        self.content_url = url
        self.save()
#+END_SRC

****** setSimulationURL: Experiment, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_simulation_url(self, url):
        self.simulation_url = url
        self.save()
#+END_SRC

****** setContentHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC 
    @typecheck(platform=HostingPlatform)
    def set_content_hosted_on(self, platform):
        self.content_hosted_on = platform
        self.save()
#+END_SRC

****** setSimulationHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC 
    @typecheck(platform=HostingPlatform)
    def set_simulation_hosted_on(self, platform):
        self.simulation_hosted_on = platform
        self.save()
#+END_SRC

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'content_url': self.content_url,
            'content_on': self.content_on,
            'simulation_url': self.simulation_url,
            'simulation_on': self.simulation_on,
            'lab': self.lab.to_client()
        }
#+END_SRC

**** Lab
***** Immutable Data
      
      These are the data associated with Lab type, which are immutable.

      + LabId
      + Mnemonic
      + NoOfExperiments
  
      As the number of experiments should be derived by the system from the
      experiments already associated with each lab.

***** Mutable Data
      These are the data associated with Lab type, which are mutable.

      + Name
      + Institute
      + Discipline
      + IntegrationLevel
      + HostedURL
      + RepoURL
      + TypeOfLab
      + HostedOn
      + Web2Compliant
      + Phase2Lab
      + Developer
      + Technology
      + Experiment

***** TODO: Mnemonic assigned for each lab
***** Association
#+BEGIN_SRC python :tangle src/db.py :eval no
# association table of developers and labs                                                                                            
developers_engaged = db.Table(                                                      
    'developers_engaged',                                                           
    db.Column('lab_id', db.Integer, db.ForeignKey('labs.id')),                      
    db.Column('developer_id', db.Integer, db.ForeignKey('developers.id'))
)

 # association table of technologies and labs                                        
technologies_used_labs = db.Table(                                                  
    'technologies_used_labs',                                                       
    db.Column('lab_id', db.Integer, db.ForeignKey('labs.id')),                      
    db.Column('tech_id', db.Integer, db.ForeignKey('technologies.id'))              
)                                                                                  
     
#+END_SRC
***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Lab(Entity):

    __tablename__ = 'labs'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    slug = db.Column(db.String(128))

    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))
    discipline_id = db.Column(db.Integer, db.ForeignKey('disciplines.id'))

    integration_level_id = db.Column(db.ForeignKey('integration_levels.id'))

    developers = db.relationship('Developer', secondary=developers_engaged,
                                 backref='labs')

    number_of_experiments = db.Column(db.Integer)

    experiments = db.relationship('Experiment', backref='lab')

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_labs,
                                   backref='labs')

    repo_url = db.Column(db.String(256))

    hosted_url = db.Column(db.String(256))

    hosted_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))

    type_of_lab_id = db.Column(db.ForeignKey('type_of_labs.id'))

    remarks = db.Column(db.Text)
    status = db.Column(db.String(32))

    is_web_2_compliant = db.Column(db.Boolean)
    is_phase_2_lab = db.Column(db.Boolean)
#+END_SRC
      

***** Functions that operate on the Lab domain
****** getId: Lab --> LabId
#+BEGIN_SRC 
    def get_id(self):
        return self.id

#+END_SRC

****** getLab: LabId --> Lab
#+BEGIN_SRC 
    @staticmethod
    def get_lab_by_id(id):
        return Lab.query.get(id)
#+END_SRC

****** getAllLabs: Nil --> set[Lab]
#+BEGIN_SRC 
    @staticmethod
    def get_all(fields=None):
        # get all labs from db
        labs = [i.to_client() for i in Lab.query.all()]
        print 'total count of labs'
        print len(labs)
        # print fields
        # if request do not contain fields, return the data
        if not fields:
            return labs
        # if fields exist in the request, format all the labs to have only the
        # fields requested by the user
        formatted_labs = Lab.format_labs_by_fields(labs, fields)
        return formatted_labs
#+END_SRC

****** getMnemonic: Lab --> Mnemonic
#+BEGIN_SRC 
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

****** getLab: Mnemonic --> Lab
#+BEGIN_SRC 
    @staticmethod
    def get_lab_by_mnemonic(mnemonic):
        return Lab.query.filter_by(mnemonic=mnemonic).first()
#+END_SRC

****** getName: Lab --> Name

       This is similar to the =getId= function and all types will have this
       function.
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

****** getIntegrationLevel: Lab --> Level
#+BEGIN_SRC 
    def get_integration_level(self):
        return self.integration_level.level
#+END_SRC

****** getHostedURL: Lab --> Nil + URL

       URL: when hosted

       Nil: when not hosted
#+BEGIN_SRC 
    def get_hosted_url(self):
        return self.hosted_url
#+END_SRC
       
****** getRepoURL: Lab --> Nil + URL

       URL: when sources are available

       Nil: otherwise
#+BEGIN_SRC 
    def get_repo_url(self):
        return self.repo_url
#+END_SRC

****** getType: Lab --> TypeOfLab
#+BEGIN_SRC 
    def get_type(self):
        return self.type_of_lab
#+END_SRC

****** getNoOfExperiments: Lab --> Nat
#+BEGIN_SRC 
    def get_num_of_experiments(self):
        return len(self.experiments)
#+END_SRC

****** getHostedOn: Lab --> HostingPlatform + Nil
#+BEGIN_SRC 
    def get_hosted_on(self):
        return self.hosted_on
#+END_SRC

****** isWeb2Compliant: Lab --> Boolean
#+BEGIN_SRC 
    def is_web_2_compliant(self):
        return self.is_web_2_compliant
#+END_SRC

****** isPhase2Lab: Lab --> Boolean
#+BEGIN_SRC 
    def is_phase_2(self):
        return self.is_phase_2_lab
#+END_SRC

****** getDiscipline: Lab --> Discipline
#+BEGIN_SRC 
    def get_discipline(self):
        return self.discipline
#+END_SRC

****** getExperiments: Lab --> set[Experiment]
#+BEGIN_SRC 
    def get_experiments(self):
        return self.experiments
#+END_SRC

****** getInstitute: Lab --> Institute
#+BEGIN_SRC 
    def get_institute(self):
        return self.institute
#+END_SRC

****** getDevelopers: Lab --> set[Developer]
#+BEGIN_SRC 
    def get_developers(self):
        return self.developers
#+END_SRC

****** getTechnologies: Lab --> set[Technology]
#+BEGIN_SRC 
    def get_technologies(self):
        return self.technologies
#+END_SRC

****** setName: Lab, Name --> Void

       NOTE: All types will have a =setName= function.
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC

****** setInstitute: Lab, Institute --> Void
#+BEGIN_SRC 
    @typecheck(institute=Institute)
    def set_institute(self, institute):
        self.institute = institute
        self.save()
#+END_SRC

****** setDiscipline: Lab, Discipline --> Void
#+BEGIN_SRC 
    @typecheck(discipline=Discipline)
    def set_discipline(self, discipline):
        self.discipline = discipline
        self.save()
#+END_SRC

****** setIntegrationLevel: Lab, Level --> Void
#+BEGIN_SRC 
    @typecheck(level=IntegrationLevel)
    def set_integration_level(self, level):
        self.integration_level = level
        self.save()
#+END_SRC

****** setHostedURL: Lab, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_hosted_url(self, url):
        self.hosted_url = url
        self.save()
#+END_SRC

****** setRepoURL: Lab, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_repo_url(self, url):
        self.repo_url = url
        self.save()
#+END_SRC

****** setTypeOfLab: Lab, TypeOfLab --> Void
#+BEGIN_SRC 
    @typecheck(type=TypeOfLab)
    def set_type_of_lab(self, type):
        self.type_of_lab = type
        self.save()
#+END_SRC

****** setHostedOn: Lab, HostingPlatform --> Void
#+BEGIN_SRC 
    @typecheck(platform=HostingPlatform)
    def set_hosted_on(self, platform):
        self.hosted_on = platform
        self.save()
#+END_SRC

****** setisWeb2Compliant: Lab, Boolean --> Void
#+BEGIN_SRC 
    @typecheck(compliant=bool)
    def set_is_web_2_compliant(self, compliant):
        self.is_web_2_compliant = compliant
        self.save()
#+END_SRC

****** setisPhase2: Lab, Boolean --> Void
#+BEGIN_SRC 
    @typecheck(phase2=bool)
    def set_is_phase_2_lab(self, phase2):
        self.is_phase_2_lab = phase2
        self.save()
#+END_SRC

****** addDeveloper: Lab, Developer --> Void
#+BEGIN_SRC 
    @typecheck(developer=Developer)
    def add_developer(self, developer):
        self.developers.append(developer)
        self.save()
#+END_SRC

****** removeDeveloper: Lab, Developer --> Void
#+BEGIN_SRC 
    @typecheck(developer=Developer)
    def remove_developer(self, developer):
        if developer in self.developers:
            self.developers.remove(developer)
            self.save()
#+END_SRC

****** addTechnology: Lab, Technology --> Void
#+BEGIN_SRC 
    @typecheck(technology=Technology)
    def add_technology(self, technology):
        self.technologies.append(technology)
        self.save()
#+END_SRC

****** removeTechnology: Lab, Technology --> Void
#+BEGIN_SRC 
    @typecheck(technology=Technology)
    def remove_technology(self, technology):
        if technology in self.technologies:
            self.technologies.remove(technology)
            self.save()
#+END_SRC

****** addExperiment: Lab, Experiment --> Void
#+BEGIN_SRC 
    @typecheck(experiment=Experiment)
    def add_experiment(self, experiment):
        self.experiments.append(experiment)
        self.save()
#+END_SRC

****** removeExperiment: Lab, Experiment --> Void
#+BEGIN_SRC 
    @typecheck(experiment=Experiment)
    def remove_experiment(self, experiment):
        if experiment in self.experiments:
            self.experiments.remove(experiment)
            self.save()
#+END_SRC

****** formatLabsByFields
#+BEGIN_SRC 
    @staticmethod
    def format_labs_by_fields(labs, fields):
        current_app.logger.debug("labs recvd: %s" % labs)
        formatted_labs = []  # all labs
        for lab in labs:
            formatted_lab = {}  # formatted lab
            for field in fields:
                try:
                    formatted_lab[field] = lab[field]
                except KeyError:
                    raise Exception('Invalid field %s', field)

            # print fmttd_lab
            formatted_labs.append(formatted_lab)
        return formatted_labs
#+END_SRC

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'mnemonic': self.mnemonic,
            'name': self.name,
            'slug': self.slug,
            'institute': self.institute.to_client(),
            'discipline': self.discipline.to_client(),
            'integration_level': self.integration_level,
            'number_of_experiments': self.number_of_experiments,
            'repo_url': self.repo_url,
            'hosted_url': self.hosted_url,
            'hosted_on': self.hosted_on,
            'technologies': self.technologies,
            'developers': self.developers,
            'type_of_lab': self.type_of_lab,
            'status': self.status,
            'is_web_2_compliant': self.is_web_2_compliant,
            'is_phase_2_lab': self.is_phase_2_lab,
            'remarks': self.remarks
        }
#+END_SRC
       
*** COMMENT Functions operating on multiple domains
     
***** NOTE: is it necessary? getAllLabs: Nil --> set[Lab]

***** NOTE: is it necessary? getAllDevelopers: Nil --> set[Developer]

***** NOTE: is it necessary? getAllExperiments: Nil --> set[Experiment]


*** COMMENT Relationship between different entities
  #+CAPTION: Entity Diagram
  #+NAME:   entity
  [[https://drive.google.com/open?id%3D0B6LLRcwXMzt8N3RzZGVkb0NpUDA][ER-Diagram]]
  
** Exceptions
*** AttributeRequired
#+BEGIN_SRC python :tangle src/ds_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC
* Test Cases
** __init__ 
#+BEGIN_SRC python :tangle tests/__init__.py :eval no
#something
print "test package"
#+END_SRC

**  API Tests
#+BEGIN_SRC python :tangle tests/test_db.py :eval no
# -*- coding: utf-8 -*-

import unittest
from flask.ext.testing import TestCase
# import json
from src.db import *
from src.app import create_app

config = {
    'SQLALCHEMY_DATABASE_URI': 'mysql+oursql://root:root@localhost:8080/dataservice'
}


class TestCustomTypes(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    # Test the Name type
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")

    # Test the Email type
    def test_correct_email_type(self):
        print "test_correct_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")


class TestLab(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    # def create_lab_prereqs(self):
    #    instt = Institute(name="MIT", mnemonic="mit")
    #    disc = Discipline(name="CS", mnemonic="cs")
    #    exp = Experiment(name="exp1")
    #    ilevel = IntegrationLevel(level=6)
    #    dev = Developer(name="Joe", institute=instt)

    def test_lab_get_lab_by_id(self):
        print "test_lab_get_lab_by_id"
        lab = Lab(name="DS", mnemonic="ds")
        lab.save()
        some_lab = Lab.get_lab_by_id(1)
        self.assertEqual(some_lab, lab)

    def test_lab_get_lab_by_mnemonic(self):
        print "test_lab_get_lab_by_mnemonic"
        lab = Lab(name="DS", mnemonic="ds")
        lab.save()
        some_lab = Lab.get_lab_by_mnemonic("ds")
        self.assertEqual(some_lab, lab)

    def test_lab_get_id(self):
        print "test_lab_get_id"
        lab = Lab(name="DS", mnemonic="ds")
        lab.save()
        self.assertEqual(lab.get_id(), 1)

    def test_lab_get_mnemonic(self):
        print "test_lab_get_mnemonic"
        lab = Lab(name="DS", mnemonic="ds")
        self.assertEqual(lab.get_mnemonic(), "ds")

    def test_lab_get_name(self):
        print "test_lab_get_name"
        lab = Lab(name="DS", mnemonic="ds")
        self.assertEqual(lab.get_name(), "DS")

    def test_lab_get_institute(self):
        print "test_lab_get_institute"
        instt = Institute(name="MIT", mnemonic="mit")
        lab = Lab(name="DS", mnemonic="ds", institute=instt)
        self.assertEqual(lab.get_institute().name, "MIT")

    def test_lab_get_integration_level(self):
        print "test_lab_get_integration_level"
        ilevel = IntegrationLevel(level=1)
        lab = Lab(name="DS", mnemonic="ds", integration_level=ilevel)
        self.assertEqual(lab.get_integration_level(), 1)

    def test_lab_get_hosted_url(self):
        print "test_lab_get_hosted_url"
        lab = Lab(name="DS", mnemonic="ds", hosted_url="http://gnu.org")
        self.assertEqual(lab.get_hosted_url(), "http://gnu.org")

    def test_lab_get_developers(self):
        print "test_lab_get_developers"
        dev1 = Developer(name="Joe")
        dev2 = Developer(name="Smith")
        devs = [dev1, dev2]
        lab = Lab(name="DS", mnemonic="ds", developers=devs)
        self.assertItemsEqual(lab.get_developers(), devs)

    def test_lab_get_technologies(self):
        print "test_lab_get_technologies"
        tech1 = Technology(name="php5")
        tech2 = Technology(name="apache2")
        techs = [tech1, tech2]
        lab = Lab(name="DS", mnemonic="ds", technologies=techs)
        self.assertItemsEqual(lab.get_technologies(), techs)


class TestDeveloper(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    # Tests for developer entity
    def test_set_developer_name(self):
        print "test_set_developer_name"
        instt = Institute(name="MIT", mnemonic="mit")
        dev = Developer(name="Joe", institute=instt, email_id="joe@example.com")
        new_name = Name("John")
        # print "dev", new_name
        # print new_name, type(new_name)
        dev.set_name(new_name)
        self.assertEqual(dev.name, "John")
        self.assertRaises(TypeError, dev.set_name, "John")

    def test_set_developer_email(self):
        print "test_set_developer_email"
        instt = Institute(name="MIT", mnemonic="mit")
        dev = Developer(name="Joe", institute=instt, email_id="joe@example.com")
        # print dev
        new_email = Email("bob@gmail.com")
        # print new_email, type(new_email)
        dev.set_email(new_email)
        self.assertEqual(dev.email_id, "bob@gmail.com")
        self.assertRaises(TypeError, dev.set_email, "some@gmail.com")

    def test_get_developer_by_id(self):
        print "test_get_developer_by_id"
        instt = Institute(name="MIT", mnemonic="mit")
        dev = Developer(name="Joe", institute=instt, email_id="joe@example.com")
        dev.save()
        self.assertEqual(dev.get_developer(1).name, "Joe")

    def test_get_developer_email(self):
        print "test_get_developer_email"
        instt = Institute(name="MIT", mnemonic="mit")
        dev = Developer(name="Joe", institute=instt, email_id="joe@example.com")
        email_id = dev.get_email()
        self.assertEqual(email_id, "joe@example.com")

    def test_get_developer_name(self):
        print "test_get_developer_name"
        instt = Institute(name="MIT", mnemonic="mit")
        dev = Developer(name="Joe", institute=instt, email_id="joe@example.com")
        name = dev.get_name()
        self.assertEqual(name, "Joe")

   
class TestInstitute(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    # Tests for Institute entity.
    def test_set_institute_pic(self):
        print "test_set_institute_pic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="Avinash", iic="Amit")
        new_pic = Name("John Doe")
        # print new_pic
        instt.set_pic(new_pic)
        self.assertEqual(instt.pic, "John Doe")

    def test_set_institute_iic(self):
        print "test_set_institute_iic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Amit")
        new_iic = Name("Jane Doe")
        # print new_iic
        instt.set_iic(new_iic)
        self.assertEqual(instt.iic, "Jane Doe")

    def test_set_institute_name(self):
        print "test_set_institute_name"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Amit")
        new_name = InstituteName("IIT-Hyd Telangana")
        instt.set_name(new_name)
        self.assertEqual(instt.name, "IIT-Hyd Telangana")

    def test_get_institute_name(self):
        print "test_get_institute_name"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        inst_name = instt.get_name()
        self.assertEqual(inst_name, "IndianInstitute")

    def test_get_institute_pic(self):
        print "test_get_institute_pic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        inst_pic = instt.get_pic()
        self.assertEqual(inst_pic, "John")

    def test_get_institute_iic(self):
        print "test_get_institute_iic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        inst_iic = instt.get_iic()
        self.assertEqual(inst_iic, "Jane")

    def test_get_id_of_institute(self):
        print "test_get_id_of_institute"
        instt = Institute(id="1", name="SomeInstitute", mnemonic="si")
        institute_id = instt.get_id()
        self.assertEqual(institute_id, "1")

    def test_get_institute_by_id(self):
        print "test_get_institute_by_id"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        instt.save()
        self.assertEqual(instt.get_institute_by_id(1).name, "IndianInstitute")

    def test_get_institute_labs(self):
        print "test_get_institute_labs"
        lab1 = Lab(name="Micro Controllers", mnemonic="micro")
        lab2 = Lab(name="Digital Logic Design", mnemonic="digital")
        labs = [lab1, lab2]
        instt = Institute(name="MIT", mnemonic="mit", labs=labs)
        self.assertItemsEqual(instt.get_labs(), labs)
        
class TestDiscipline(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    # Test for set_dnc attribute of Discipline entity
    def test_set_discipline_dnc(self):
        print "test_set_discipline_dnc"
        disc = Discipline(name="CSE", mnemonic="cs")
        new_dnc = Name("James roy")
        disc.set_dnc(new_dnc)
        self.assertEqual(disc.dnc, "James roy")
        self.assertRaises(TypeError, disc.set_dnc, "123 James roy")

    # Test for get_id attribute of Discipline entity
    def test_get_discipline_id(self):
        print "test_get_discipline_id"
        disc = Discipline(name="CSE", mnemonic="cs")
        disc.save()
        self.assertEqual(disc.id, disc.get_id())

    # Test for get_dnc attribute of Discipline entity
    def test_get_discipline_dnc(self):
        print "test_get_discipline_dnc"
        disc = Discipline(name="CSE", mnemonic="cs", dnc="James")
        self.assertEqual(disc.get_dnc(), "James")

    def test_get_discipline_by_id(self):
        print "test_get_discipline_name"
        disc = Discipline(name="CSE", mnemonic="cs", dnc="James")
        disc.save()
        self.assertEqual(disc.get_discipline_by_id(1).name, disc.name)

    def test_get_discipline_labs(self):
        print "test_get_discipline_labs"
        lab1 = Lab(name="Micro Controllers", mnemonic="micro")
        lab2 = Lab(name="Digital Logic Design", mnemonic="digital")
        labs = [lab1, lab2]
        disc = Discipline(name="Electronics", mnemonic="ece", labs=labs)
        self.assertItemsEqual(disc.get_labs(), labs)

if __name__ == '__main__':
    unittest.main()

#+END_SRC

** APP.py
#+BEGIN_SRC python :tangle src/app.py :eval no
# -*- coding: utf-8 -*-

import os
import logging
from logging.handlers import RotatingFileHandler

from flask import Flask, jsonify, make_response
from flask.ext.cors import CORS

from db import db
# import config file
import config


def create_app(config):
    # init our app
    app = Flask(__name__)

    # load config values from the config file
    app.config.from_object(config)

    # init sqlalchemy db instance
    db.init_app(app)
    db.app = app

    # register blueprints
#    app.register_blueprint(api)

    configure_errorhandlers(app)
    configure_cors(app)
    configure_logging(app)

    # all set; return app object
    return app


# configure cross origin resource sharing
def configure_cors(app):
    # CORS(app)
    CORS(app, origins=config.ALLOWED_ORIGINS,
         methods=['GET', 'OPTIONS', 'PUT', 'POST'],
         allow_headers='Content-Type')


# custom error handlers to return JSON errors with appropiate status codes
def configure_errorhandlers(app):

    @app.errorhandler(404)
    def not_found(err):
        if 'description' not in err:
            return make_response(jsonify(error='No such URL found'), 404)

        return make_response(jsonify(error=err.description), 404)

    @app.errorhandler(400)
    def bad_request(err):
        return make_response(jsonify(error=err.description), 400)


def configure_logging(app):
    formatter = logging.Formatter('%(asctime)s: %(levelname)s: %(filename)s:'
                                  ' %(funcName)s():%(lineno)d: %(message)s')

    if 'LOG_FILE' in app.config:
        log_filename = app.config['LOG_FILE']
    else:
        log_filename = 'dataservice.log'
    # Also error can be sent out via email. So we can also have a SMTPHandler?
    log_file = os.path.join(os.path.dirname(__file__), '..', log_filename)

    max_size = 1024 * 1024 * 20  # Max Size for a log file: 20MB
    log_handler = RotatingFileHandler(log_file, maxBytes=max_size,
                                      backupCount=10)

    if 'LOG_LEVEL' in app.config:
        log_level = app.config['LOG_LEVEL'] or 'ERROR'
    else:
        log_level = 'ERROR'

    log_handler.setLevel(log_level)
    log_handler.setFormatter(formatter)

    app.logger.addHandler(log_handler)


if __name__ == "__main__":
    app = create_app(config)
    app.run(debug=True, host='0.0.0.0')

#+END_SRC

** Config
#+BEGIN_SRC python :tangle src/config.py :eval no
# DB URI
# example DB URI:
# mysql+oursql://scott:tiger@localhost/mydatabase
# postgresql+psycopg2://scott:tiger@localhost/mydatabase
SQLALCHEMY_DATABASE_URI =\
    'mysql+oursql://root:mysql@localhost/dataservice'

# Debug from SQLAlchemy
# Turn this to False on production
SQLALCHEMY_ECHO = False

# List of allowed origins for CORS
ALLOWED_ORIGINS = ["*"]

# Configure your log paths
LOG_FILE = 'logs/dataservice.log'

# Log level for the application
LOG_LEVEL = 'ERROR'

#+END_SRC
* Provisioning
  [[./setup.org][Set up the environment]]
* Design discussions
* Releases
** v0.1.0
    This release will satisfy requirements 1 & 2
    Release Date :: [2015-08-26 Wed]
*** Work Split
**** Overview
     #+CAPTION: Total Hours
     #+NAME:    total-hours

     |------------------+------------------+--------+--------+--------|
     |                  |                  |        |        | Total  |
     |                  |                  | No. of | No. of | number |
     | Start Date       | End Date         | days   | people | of     |
     |                  |                  |        |        | person |
     |                  |                  |        |        | days   |
     |------------------+------------------+--------+--------+--------|
     | [2015-08-13 Thu] | [2015-08-26 Wed] | 10     | 5      | 50     |
     |------------------+------------------+--------+--------+--------|

**** Detailed
     #+CAPTION: Detailed Hours
     #+NAME:    detailed-hours

     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Task Name            |                  | Date of Completion |                         |      |           Effort |
     |                      | Start Date       |                    | no.                     |  no. | (in person days) |
     |                      |                  |                    | of                      |   of |                  |
     |                      |                  |                    | persons                 | days |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Data Model           | [2015-08-13 Thu] | [2015-08-18 Tue]   | 1                       |    4 |                4 |
     | (Initial Cut)        |                  |                    |                         |      |                  |
     |                      |                  |                    |                         |      |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Python API           |                  |                    |                         |      |                  |
     | & REST API           | [2015-08-19 Wed] | [2015-08-26 Wed]   | 2                       |    6 |               12 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | VIEW -               |                  |                    | 4 till [2015-08-18 Tue] |    4 |               16 |
     | list, detail         | [2015-08-13 Thu] | [2015-08-26 Wed]   |                         |      |                  |
     | and update           |                  |                    |                         |      |                  |
     |                      |                  |                    | 2 till [2015-08-26 Wed] |    6 |               12 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Provisioning &       |                  |                    |                         |      |                  |
     | Data Model Evolution | [2015-08-19 Wed] | [2015-08-26 Wed]   | 1                       |    6 |                6 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Filters              |                  |                    |                         |      |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|

*** Tasks & Deadlines
    1. Data Model
       + Completion Date :: [2015-08-18 Tue]
       + Effort :: 3 person days
       + Tasks
         - Describe each entity and capture the model of data for each entity.
         - Describe the relationship between all the entities.
    2. Python API , REST API and Migration scripts from old data to new model
       + Completion Data :: [2015-08-26 Wed]
       + Effort :: 12 person days
       + Tasks
         - Provide Python API to perform CRUD operations on different entities.
         - Provide REST API for different application to perform CRUD
           operations on different entities.
         - Provide a migration script that converts the legacy data into the
           new data model.
    3. VIEW - list, detail and update views of each entity
       + Completion Data :: [2015-08-26 Wed]
       + Effort :: 12 person days
       + Tasks
         - Provide a mechanism to list all the rows in an entity for all entities.
         - Provide a mechanism to a detailed view of a row in a selected entity.
         - Provide a mechanism to update a row in an entity.

    4. Filters

    5. Provisioning

