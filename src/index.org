#+TITLE: Dataservice
#+Author: VLEAD
#+Date: [2015-08-13 Thu]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org

* Introduction
  Dataservice is a micro service that allows persistence of data by other micro
  services over HTTP using REST API.  dataservie hides the implementation
  details of the data store that is required for data persistence.

* Requirements
  1. The model of the data on whose foundation dataservice is built is
     explicitly laid out. <<req1>>
  2. Python API is provided as a wrapper to make CRUD operations on the data.
  3. REST API is provided for various applications to perform CRUD operations
     on the data.

* Design & Implementation
** Python
*** __init__
#+BEGIN_SRC python :tangle src/__init__.py :eval no
print "src package"
import db

#+END_SRC
*** imports
#+BEGIN_SRC python :tangle src/db.py :eval no
# -*- coding: utf-8 -*-

from flask.ext.sqlalchemy import SQLAlchemy
from flask import current_app

import re
from urlparse import urlparse

from ds_exceptions import AttributeRequired
from utils import typecheck

db = SQLAlchemy()


# Abstract class to hold common methods
class Entity(db.Model):

    __abstract__ = True

    # save a db.Model to the database. commit it.
    def save(self):
        db.session.add(self)
        db.session.commit()

    # update the object, and commit to the database
    def update(self, **kwargs):
        for attr, val in kwargs.iteritems():
            self.__setattr__(attr, val)

        self.save()

#+END_SRC

** Data Model
   Description of the data model.

*** Types & Functions: List of all the types and functions in the model

**** Name

     Name is an alphabetical string.
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Name(object):
    def __init__(self, value):
        # if the string contains any non-alphabet and non-space character, raise
        # a type error
        if re.search('[^a-zA-Z ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC
**** Email

     Email is a type as defined in RFC 5321, 5322 and 6531.
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Email(object):
    def __init__(self, value):
        if not re.search('[^@]+@[^@]+\.[^@]+', value):
            raise TypeError('%s is not an email_id!' % value)
        self.value = value
#+END_SRC
**** URL

   URL is a type as defined in RFC 1738.

#+BEGIN_SRC python :tangle src/db.py :eval no
class URL(object):
    def __init__(self, value):
        result = urlparse(value)
        if not result.scheme or not result.netloc:
            raise TypeError("%s is not a valid URL." % value)

        self.value = value
#+END_SRC
**** Version

   Version is an alphanumeric string including '-' and '.'.

#+BEGIN_SRC python :tangle src/db.py :eval no
class Version(object):
    pass
#+END_SRC
     
**** LabId

     LabId is a natural number.

**** TechnologyId

     TechnologyId is a natural number.

**** InstituteId

     InstituteId is a natural number.

**** InstituteName
    
     InstituteName is an alphabetical string including a '-'.
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
class InstituteName(object):
    def __init__(self, value):
        # if the string contains any non-alphabet, non-hyphen and non-space
        # character, raise a type error
        if re.search('[^a-zA-Z\- ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC

**** DisciplineId

     DisciplineId is a natural number.

**** DeveloperId
     
     DeveloperId is a natural number.

**** ExperimentId

     ExperimentId is a natural number.

**** IntegrationLevel
      
   IntegrationLevel is {L0, L1, L2, L3, L4, L5, L6}.

#+BEGIN_SRC python :tangle src/db.py :eval no 
class IntegrationLevel(Entity):
    __tablename__ = 'integration_levels'
    id = db.Column(db.Integer, primary_key=True)
    level = db.Column(db.Integer, nullable=False)

    labs = db.relationship('Lab', backref='integration_level')
#+END_SRC
**** HostingPlatform

     HostingPlatform is {IIIT, Badal, AWS, Else}.

#+BEGIN_SRC python :tangle src/db.py :eval no 
class HostingPlatform(Entity):
    __tablename__ = 'hosting_platforms'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(32), nullable=False)

    labs = db.relationship('Lab', backref='hosted_on')
#+END_SRC
**** TypeOfLab

     TypeOfLab is 
     { Simulation,
     Remote Triggered,
     Simulation and Remote Triggered,
     Pilot Phase }
     
#+BEGIN_SRC python :tangle src/db.py :eval no
class TypeOfLab(Entity):
    __tablename__ = 'type_of_labs'
    id = db.Column(db.Integer, primary_key=True)
    type = db.Column(db.String(64), nullable=False)

    labs = db.relationship('Lab', backref='type_of_lab')
#+END_SRC
**** Developer
***** Immutable Data
      This is the data associated with Developer type, which is immutable.
      + DeveloperId
***** Mutable Data
      This is the data associated with Developer type, which is mutable.
      + Name
      + Email
      + Institute Id

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Developer(Entity):

    __tablename__ = 'developers'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.String(64), nullable=False)
    email_id = db.Column(db.String(128))
    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))

    # signature of constructor
    # developer = Developer(name=instance of class Name,
    #               email_id=instance of Email,
    #               institute=instance of Institute)
    def __init__(self, **kwargs):
        keys = kwargs.keys()
        if 'name' and 'email_id' and 'institute' not in keys:
            raise AttributeRequired("non-nullable attribute(s) missing")

            if not isinstance(kwargs['name'], Name):
                raise TypeError("kwargs['name'] is not of type Name")
            if not isinstance(kwargs['email_id'], Email):
                raise TypeError("kwargs['email_id'] is not of type Email")
            if not isinstance(kwargs['institute'], Name):
                raise TypeError("kwargs['institute'] is not of type Institute")
            

        

        
            
            
#+END_SRC

***** Functions that operate on the Developer domain
****** getId: Developer --> DeveloperId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC
       
****** getName: Developer --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

****** getAllDevelopers: Nil --> set[Developer]
#+BEGIN_SRC 
    @staticmethod
    def get_developer(id):
        return Developer.query.get(id)
#+END_SRC

****** getLabs: Developer --> set[Lab]
#+BEGIN_SRC 

#+END_SRC

****** getInstitute: Developer --> Institute
#+BEGIN_SRC 

#+END_SRC

****** getDeveloper: DeveloperId --> Developer
#+BEGIN_SRC 
    def get_developer(id):
        return Developer.query.get(id)
#+END_SRC

****** getEmail: Developer --> Email
#+BEGIN_SRC 
    def get_email(self):
        return self.email_id
#+END_SRC

****** setName: Developer, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC

****** setEmail: Developer, Email --> Void
#+BEGIN_SRC 
    @typecheck(email_id=Email)
    def set_email(self, email_id):
        self.email_id = email_id.value
#+END_SRC

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'email_id': self.email_id,
            'name': self.name,
            'institute': self.institute.to_client()
        }
#+END_SRC

**** Institute

***** Immutable Data
This is the data associated with Institute type, which is immutable.

+ InstituteId
+ Mnemonic

***** Mutable Data

These are the data associated with Institute type, which are mutable

+ PIC
+ IIC

***** Mnemonic assigned to each institute
|---------------------------------+----------|
| Name                            | Mnemonic |
|---------------------------------+----------|
| IIIT Hyderabad                  | iiith    |
| IIT Bombay                      | iitb     |
| IIT Delhi                       | iitd     |
| IIT Roorkee                     | iitrrk   |
| IIT Guwahati                    | iitg     |
| IIT Kanpur                      | iitk     |
| IIT Kharagpur                   | iitkgp   |
| IIT Madras                      | iitm     |
| NIT Surathkal                   | nitk     |
| Amrita University               | amrita   |
| College of Engineering, Pune    | coep     |
| Dayalbagh Educational Institute | dei      |
|---------------------------------+----------|

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Institute(Entity):

    __tablename__ = 'institutes'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    pic = db.Column(db.String(128))
    iic = db.Column(db.String(128))

    labs = db.relationship('Lab', backref='institute')
    developers = db.relationship('Developer', backref='institute')

    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("name is required when initializing an institute")

        if not isinstance(kwargs['name'], InstituteName):
            raise TypeError("kwargs['name'] is not of type InstituteName")

        self.name = name

        if 'mnemonic' not in kwargs:
            raise AttributeRequired("mnemonic is required when initializing an institute")

        if 'pic' in kwargs:
            if not isinstance(kwargs['pic'], Name):
                raise TypeError("kwargs['pic'] is not of type Name)
            self.pic = pic
              
        if 'iic' in kwargs:
            if not isinstance(kwargs['iic'], Name):
                raise TypeError("kwargs['iic'] is not of type Name)
            self.iic = iic

#+END_SRC

***** Functions that operate on Institute domain

****** getId: Institute --> InstituteId
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

****** getName: Institute --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_name(self):
        return self.name

#+END_SRC

****** getInstitute: InstituteId --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @staticmethod
    def get_institute_by_id(id):
        return Institute.query.get(id)

#+END_SRC

****** getMnemonic: Institute --> Mnemonic
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_mnemonic(self):
        return self.mnemonic

#+END_SRC

****** getInstitute: Mnemonic --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @staticmethod                                                                
    def get_institute_by_mnemonic(mnemonic):                                     
        return Institute.query.filter_by(mnemonic=mnemonic).first()              

#+END_SRC

****** getPIC: Institute --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_pic(self):
        return self.pic

#+END_SRC
      
****** getIIC: Institute --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_iic(self):
        return self.iic

#+END_SRC

****** getLabs: Institute --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_labs(self):
        return self.labs

#+END_SRC

****** getDevelopers: Institute --> set[Developer]
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_developers(self):
        return self.developers

#+END_SRC

****** getAllInstitutes: Nil --> set[Institute]
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Institute.query.all()]

#+END_SRC

****** setPIC: Institute, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(pic=Name)
    def set_pic(self, pic):
        self.pic = pic.value

#+END_SRC

****** setIIC: Institute, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(iic=Name)
    def set_iic(self, iic):
        self.iic = iic.value

#+END_SRC
      
****** setName: Institute, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(name=InstituteName)
    def set_name(self, name):
        self.name = name.value

#+END_SRC

****** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'mnemonic': self.mnemonic,
            'pic': self.pic,
            'iic': self.iic
        }

#+END_SRC
**** Discipline

***** Immutable Data
This is the data associated with Discipline type, which is immutable.

+ DisciplineId
+ Mnemonic

***** Mutable Data
This is the data associated with Discipline type, which is mutable.

+ DNC

***** Mnemonic assigned to each discipline
|------------------------------------------+-----------|
| Name                                     | Mnemonic  |
|------------------------------------------+-----------|
| Aerospace Engineering                    | aero      |
| Biotechnology and Biomedical Engineering | biotech   |
| Chemical Engineering                     | chem-engg |
| Chemical Sciences                        | chem      |
| Civil Engineering                        | civil     |
| Computer Science and Engineering         | cse       |
| Electrical Engineering                   | ee        |
| Electronics and Communication            | ece       |
| Humanities                               | human     |
| Mechanical Engineering                   | mech      |
| Physical Sciences                        | phy-sc    |
| Textile Engineering                      | tex-engg  |
| Design Engineering                       | dsgn-engg |
| Material Sciences                        | mat-sc    |
|------------------------------------------+-----------|

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Discipline(Entity):

    __tablename__ = 'disciplines'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    dnc = db.Column(db.String(64))

    labs = db.relationship('Lab', backref='discipline')

    def __init__(self, **kwargs):
        if 'name' not in kwargs:
            raise AttributeRequired("name is required when initializing discipline")

        if not isinstance(kwargs['name'], Name):
            raise TypeError("kwargs['name'] is not of type Name")

        self.name = name

        if 'mnemonic' not in kwargs:
            raise AttributeRequired("mnemonic is required when initializing discipline")

        if 'dnc' in kwargs:
            if not isinstance(kwargs['dnc'], Name):
                raise TypeError("kwargs['dnc'] is not of type Name")
            self.dnc = dnc

#+END_SRC


***** Functions that operate on Discipline domain
****** getAllDisciplines: Nil --> set[Discipline]
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Discipline.query.all()]

#+END_SRC

****** getId: Discipline --> DisciplineId
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_id(self):
        return self.id

#+END_SRC

****** getName: Discipline --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_name(self):
        return self.name

#+END_SRC
****** getDiscipline: DisciplineId --> Discipline
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_discipline_by_id(id):
        return Discipline.query.get(id)

#+END_SRC

****** getMnemonic: Discipline --> Mnemonic
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_mnemonic(self):
        return self.mnemonic

#+END_SRC

****** getDiscipline: Mnemonic --> Discipline
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @staticmethod
    def get_discipline_by_mnemonic(mnemonic):
        return Discipline.query.filter_by(mnemonic=mnemonic).first()

#+END_SRC

****** getLabs: Discipline --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_labs(self):
        return self.labs

#+END_SRC

****** getDNC: Discipline --> Name
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_dnc(self):
        return self.dnc

#+END_SRC

****** setName: Discipline --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value

#+END_SRC

****** setDNC: Discipline, Name --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value

#+END_SRC      

****** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'mnemonic': self.mnemonic,
            'dnc': self.dnc
        }

#+END_SRC
**** Technology

***** Immutable Data
This is the data associated with Technology type, which is immutable.

+ TechnologyId

***** Mutable Data
These are the data associated with Technoloy type, which are mutable.

+ Version
+ FOSS

***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Technology(Entity):

    __tablename__ = 'technologies'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    version = db.Column(db.String(32))
    foss = db.Column(db.Boolean)
#+END_SRC

***** Functions that operate on the Technology domain
****** getId: Technology --> TechnologyId

****** getAllTechnologies: Nil --> set[Technology]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Technology.query.all()]
#+END_SRC

****** getLabs: Technology --> set[Lab]
#+BEGIN_SRC 

#+END_SRC

****** getTechnology: TechnologyId --> Technology

****** getVersion: Technology --> Version

****** isFOSS: Technology --> Boolean

****** setVersion: Technology, Version --> Void

****** setFOSS: Technology, Boolean --> Void

****** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'version': self.version,
            'foss': self.foss
        }
#+END_SRC
**** Experiment

***** Immutable Data
      This is the data associated with Experiment type, which is immutable.

      + ExperimentId

***** Mutable Data
      These are the data associated with Discipline type, which are mutable.

      + ContentURL
      + SimulationURL
      + ContentHostedOn
      + SimulationHostedOn

***** Association
#+BEGIN_SRC python :tangle src/db.py :eval no
# association table of technologies and experiments                              
technologies_used_expt = db.Table(                                               
    'technologies_used_expt',                                                    
    db.Column('expt_id', db.Integer, db.ForeignKey('experiments.id')),           
    db.Column('tech_id', db.Integer, db.ForeignKey('technologies.id'))           
) 
#+END_SRC
***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Experiment(Entity):

    __tablename__ = 'experiments'

    id = db.Column(db.Integer, primary_key=True)

    # Our data set has really, really long experiment names and URLs!!
    name = db.Column(db.String(256))

    lab_id = db.Column(db.Integer, db.ForeignKey('labs.id'))

    content_url = db.Column(db.String(256))
    # content_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    content_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    content_on = db.relationship('HostingPlatform',
                                 foreign_keys=[content_on_id])

    simulation_url = db.Column(db.String(256))
    # simulation_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    simulation_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    simulation_on = db.relationship('HostingPlatform',
                                    foreign_keys=[simulation_on_id])

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_expt,
                                   backref='experiments')

#+END_SRC

Following is the constructor for this class.

#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):
        # TODO: implement the constructor and check the validity!
        pass

#+END_SRC

***** Functions that operate on the Experiment domain

****** getId: Experiment --> ExperimentId
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_id(self):
        return self.id

#+END_SRC

****** getExperiment: ExperimentId --> Experiment
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @staticmethod
    def get_experiment(id):
        return Experiment.query.get(id)

#+END_SRC

****** getContentURL: Experiment --> URL + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_content_url(self):
        return self.content_url

#+END_SRC

****** getSimulationURL: Experiment --> URL + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_simulation_url(self):
        return self.simulation_url

#+END_SRC

****** getTechnologies: Experiment --> set[Technology]
#+BEGIN_SRC python :tangle src/db.py :eval no 

#+END_SRC

****** contentHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def content_hosted_on(self):
        return self.content_hosted_on

#+END_SRC

****** simulationHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def simulation_hosted_on(self):
        return self.simulation_hosted_on

#+END_SRC

****** getLab: Experiment --> Lab
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def get_lab(self):
        return self.lab

#+END_SRC

****** setContentURL: Experiment, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(url=URL)
    def set_content_url(self, url):
        self.content_url = url
        self.save()

#+END_SRC

****** setSimulationURL: Experiment, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(url=URL)
    def set_simulation_url(self, url):
        self.simulation_url = url
        self.save()

#+END_SRC

****** setContentHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(platform=HostingPlatform)
    def set_content_hosted_on(self, platform):
        self.content_hosted_on = platform
        self.save()

#+END_SRC

****** setSimulationHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no 
    @typecheck(platform=HostingPlatform)
    def set_simulation_hosted_on(self, platform):
        self.simulation_hosted_on = platform
        self.save()

#+END_SRC

****** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'content_url': self.content_url,
            'content_on': self.content_on,
            'simulation_url': self.simulation_url,
            'simulation_on': self.simulation_on,
            'lab': self.lab.to_client()
        }

#+END_SRC

**** Lab
***** Immutable Data
      
      These are the data associated with Lab type, which are immutable.

      + LabId
      + Mnemonic
      + NoOfExperiments
  
      As the number of experiments should be derived by the system from the
      experiments already associated with each lab.

***** Mutable Data
      These are the data associated with Lab type, which are mutable.

      + Name
      + Institute
      + Discipline
      + IntegrationLevel
      + HostedURL
      + RepoURL
      + TypeOfLab
      + HostedOn
      + Web2Compliant
      + Phase2Lab
      + Developer
      + Technology
      + Experiment

***** TODO: Mnemonic assigned for each lab
***** Association
#+BEGIN_SRC python :tangle src/db.py :eval no
# association table of developers and labs                                                                                            
developers_engaged = db.Table(                                                      
    'developers_engaged',                                                           
    db.Column('lab_id', db.Integer, db.ForeignKey('labs.id')),                      
    db.Column('developer_id', db.Integer, db.ForeignKey('developers.id'))
)

 # association table of technologies and labs                                        
technologies_used_labs = db.Table(                                                  
    'technologies_used_labs',                                                       
    db.Column('lab_id', db.Integer, db.ForeignKey('labs.id')),                      
    db.Column('tech_id', db.Integer, db.ForeignKey('technologies.id'))              
)                                                                                  
     
#+END_SRC
***** Definition
#+BEGIN_SRC python :tangle src/db.py :eval no
class Lab(Entity):

    __tablename__ = 'labs'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    slug = db.Column(db.String(128))

    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))
    discipline_id = db.Column(db.Integer, db.ForeignKey('disciplines.id'))

    integration_level_id = db.Column(db.ForeignKey('integration_levels.id'))

    developers = db.relationship('Developer', secondary=developers_engaged,
                                 backref='labs')

    number_of_experiments = db.Column(db.Integer)

    experiments = db.relationship('Experiment', backref='lab')

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_labs,
                                   backref='labs')

    repo_url = db.Column(db.String(256))

    hosted_url = db.Column(db.String(256))

    hosted_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))

    type_of_lab_id = db.Column(db.ForeignKey('type_of_labs.id'))

    remarks = db.Column(db.Text)
    status = db.Column(db.String(32))

    is_web_2_compliant = db.Column(db.Boolean)
    is_phase_2_lab = db.Column(db.Boolean)
#+END_SRC
      

***** Constructor for the Lab
#+BEGIN_SRC python :tangle src/db.py :eval no
    def __init__(self, **kwargs):

        if 'name' not in kwargs:
            raise AttributeRequired('`name` atttribute is required when '
                                    'initializaing a Lab')
        self.name = kwargs['name']

        if 'mnemonic' not in kwargs:
            raise AttributeRequired('`mnemonic` attribute is required when '
                                    'initializaing a Lab')
        self.mnemonic = kwargs['mnemonic']

        if 'institute' in kwargs:
            self.set_institute(kwargs['institute'])

        if 'discipline' in kwargs:
            self.set_discipline(kwargs['discipline'])

        if 'integration_level' in kwargs:
            self.set_integration_level(kwargs['integration_level'])

        if 'type_of_lab' in kwargs:
            self.set_type_of_lab(kwargs['type_of_lab'])

        if 'hosted_on' in kwargs:
            self.set_hosted_on(kwargs['hosted_on'])

        if 'repo_url' in kwargs:
            self.set_repo_url(kwargs['repo_url'])

        if 'hosted_url' in kwargs:
            self.set_hosted_url(kwargs['hosted_url'])

        if 'is_web_2_compliant' in kwargs:
            self.set_is_web_2_compliant(kwargs['is_web_2_compliant'])

        if 'is_phase_2_lab' in kwargs:
            self.set_is_phase_2_lab(kwargs['is_phase_2_lab'])

        if 'slug' in kwargs:
            self.set_slug(kwargs['slug'])

        if 'remarks' in kwargs:
            self.set_remarks(kwargs['remarks'])

        if 'status' in kwargs:
            self.set_status(kwargs['status'])

        if 'developers' in kwargs:
            if not isinstance(kwargs['developers'], list):
                raise TypeError('`developers` attribute should be of list '
                                'type. Each item being of Developer class')
            for developer in kwargs['developers']:
                self.add_developer(developer)

        if 'technologies' in kwargs:
            if not isinstance(kwargs['technologies'], list):
                raise TypeError('`technologies` attribute should be of '
                                'list type. Each item being of Technology '
                                'class')
            for technology in kwargs['technologies']:
                self.add_technology(technology)

        if 'experiments' in kwargs:
            if not isinstance(kwargs['experiments'], list):
                raise TypeError('`experiments` attribute should be of list '
                                'type. Each item being of Experiment class')
            for experiment in kwargs['experiments']:
                self.add_experiment(experiment)

#+END_SRC

***** Functions that operate on the Lab domain
****** getId: Lab --> LabId
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_id(self):
        return self.id

#+END_SRC

****** getLab: LabId --> Lab
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_lab_by_id(id):
        return Lab.query.get(id)
#+END_SRC

****** getAllLabs: Nil --> set[Lab]
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_all(fields=None):
        # get all labs from db
        labs = [i.to_client() for i in Lab.query.all()]
        print 'total count of labs'
        print len(labs)
        # print fields
        # if request do not contain fields, return the data
        if not fields:
            return labs
        # if fields exist in the request, format all the labs to have only the
        # fields requested by the user
        formatted_labs = Lab.format_labs_by_fields(labs, fields)
        return formatted_labs
#+END_SRC

****** getMnemonic: Lab --> Mnemonic
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

****** getLab: Mnemonic --> Lab
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def get_lab_by_mnemonic(mnemonic):
        return Lab.query.filter_by(mnemonic=mnemonic).first()
#+END_SRC

****** getName: Lab --> Name

       This is similar to the =getId= function and all types will have this
       function.
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_name(self):
        return self.name
#+END_SRC

****** getIntegrationLevel: Lab --> Level
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_integration_level(self):
        return self.integration_level.level
#+END_SRC

****** getHostedURL: Lab --> Nil + URL

       URL: when hosted

       Nil: when not hosted
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_hosted_url(self):
        return self.hosted_url
#+END_SRC
       
****** getRepoURL: Lab --> Nil + URL

       URL: when sources are available

       Nil: otherwise
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_repo_url(self):
        return self.repo_url
#+END_SRC

****** getType: Lab --> TypeOfLab
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_type(self):
        return self.type_of_lab
#+END_SRC

****** getNoOfExperiments: Lab --> Nat
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_num_of_experiments(self):
        return len(self.experiments)
#+END_SRC

****** getHostedOn: Lab --> HostingPlatform + Nil
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_hosted_on(self):
        return self.hosted_on
#+END_SRC

****** isWeb2Compliant: Lab --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_web_2_compliant(self):
        return self.is_web_2_compliant
#+END_SRC

****** isPhase2Lab: Lab --> Boolean
#+BEGIN_SRC python :tangle src/db.py :eval no
    def is_phase_2(self):
        return self.is_phase_2_lab
#+END_SRC

****** getDiscipline: Lab --> Discipline
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_discipline(self):
        return self.discipline
#+END_SRC

****** getExperiments: Lab --> set[Experiment]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_experiments(self):
        return self.experiments
#+END_SRC

****** getInstitute: Lab --> Institute
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_institute(self):
        return self.institute
#+END_SRC

****** getDevelopers: Lab --> set[Developer]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_developers(self):
        return self.developers
#+END_SRC

****** getTechnologies: Lab --> set[Technology]
#+BEGIN_SRC python :tangle src/db.py :eval no
    def get_technologies(self):
        return self.technologies
#+END_SRC

****** setName: Lab, Name --> Void

       NOTE: All types will have a =setName= function.
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC

****** setInstitute: Lab, Institute --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(institute=Institute)
    def set_institute(self, institute):
        self.institute = institute
        self.save()
#+END_SRC

****** setDiscipline: Lab, Discipline --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(discipline=Discipline)
    def set_discipline(self, discipline):
        self.discipline = discipline
        self.save()
#+END_SRC

****** setIntegrationLevel: Lab, Level --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(level=IntegrationLevel)
    def set_integration_level(self, level):
        self.integration_level = level
        self.save()
#+END_SRC

****** setHostedURL: Lab, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(url=URL)
    def set_hosted_url(self, url):
        self.hosted_url = url.value
        self.save()
#+END_SRC

****** setRepoURL: Lab, URL --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(url=URL)
    def set_repo_url(self, url):
        self.repo_url = url.value
        self.save()
#+END_SRC

****** setTypeOfLab: Lab, TypeOfLab --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(type=TypeOfLab)
    def set_type_of_lab(self, type):
        self.type_of_lab = type
        self.save()
#+END_SRC

****** setHostedOn: Lab, HostingPlatform --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(platform=HostingPlatform)
    def set_hosted_on(self, platform):
        self.hosted_on = platform
        self.save()
#+END_SRC

****** setisWeb2Compliant: Lab, Boolean --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(compliant=bool)
    def set_is_web_2_compliant(self, compliant):
        self.is_web_2_compliant = compliant
        self.save()
#+END_SRC

****** setisPhase2: Lab, Boolean --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(phase2=bool)
    def set_is_phase_2_lab(self, phase2):
        self.is_phase_2_lab = phase2
        self.save()
#+END_SRC

****** addDeveloper: Lab, Developer --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(developer=Developer)
    def add_developer(self, developer):
        self.developers.append(developer)
        self.save()
#+END_SRC

****** removeDeveloper: Lab, Developer --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(developer=Developer)
    def remove_developer(self, developer):
        if developer in self.developers:
            self.developers.remove(developer)
            self.save()
#+END_SRC

****** addTechnology: Lab, Technology --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(technology=Technology)
    def add_technology(self, technology):
        self.technologies.append(technology)
        self.save()
#+END_SRC

****** removeTechnology: Lab, Technology --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(technology=Technology)
    def remove_technology(self, technology):
        if technology in self.technologies:
            self.technologies.remove(technology)
            self.save()
#+END_SRC

****** addExperiment: Lab, Experiment --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(experiment=Experiment)
    def add_experiment(self, experiment):
        self.experiments.append(experiment)
        self.save()
#+END_SRC

****** removeExperiment: Lab, Experiment --> Void
#+BEGIN_SRC python :tangle src/db.py :eval no
    @typecheck(experiment=Experiment)
    def remove_experiment(self, experiment):
        if experiment in self.experiments:
            self.experiments.remove(experiment)
            self.save()
#+END_SRC

****** formatLabsByFields
#+BEGIN_SRC python :tangle src/db.py :eval no
    @staticmethod
    def format_labs_by_fields(labs, fields):
        current_app.logger.debug("labs recvd: %s" % labs)
        formatted_labs = []  # all labs
        for lab in labs:
            formatted_lab = {}  # formatted lab
            for field in fields:
                try:
                    formatted_lab[field] = lab[field]
                except KeyError:
                    raise Exception('Invalid field %s', field)

            # print fmttd_lab
            formatted_labs.append(formatted_lab)
        return formatted_labs
#+END_SRC

****** to_client
#+BEGIN_SRC python :tangle src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'mnemonic': self.mnemonic,
            'name': self.name,
            'slug': self.slug,
            'institute': self.institute.to_client(),
            'discipline': self.discipline.to_client(),
            'integration_level': self.integration_level,
            'number_of_experiments': self.number_of_experiments,
            'repo_url': self.repo_url,
            'hosted_url': self.hosted_url,
            'hosted_on': self.hosted_on,
            'technologies': self.technologies,
            'developers': self.developers,
            'type_of_lab': self.type_of_lab,
            'status': self.status,
            'is_web_2_compliant': self.is_web_2_compliant,
            'is_phase_2_lab': self.is_phase_2_lab,
            'remarks': self.remarks
        }
#+END_SRC
       
*** COMMENT Functions operating on multiple domains
     
***** NOTE: is it necessary? getAllLabs: Nil --> set[Lab]

***** NOTE: is it necessary? getAllDevelopers: Nil --> set[Developer]

***** NOTE: is it necessary? getAllExperiments: Nil --> set[Experiment]


*** COMMENT Relationship between different entities
  #+CAPTION: Entity Diagram
  #+NAME:   entity
  [[https://drive.google.com/open?id%3D0B6LLRcwXMzt8N3RzZGVkb0NpUDA][ER-Diagram]]
  
** Exceptions
*** AttributeRequired
#+BEGIN_SRC python :tangle src/ds_exceptions.py :eval no
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC
** Utility Functions
#+BEGIN_SRC python :tangle src/utils.py :eval no 
# module to hold all utilities/helper functions

import json

from flask import make_response


# return a list of dicts as json with correct mime types
# flask does not provide a jsonify for lists; hence this method
def jsonify_list(data):
    if type(data) is not list:
        raise Exception('jsonify_list function accepts only a list')

    return make_response(json.dumps(data), 200,
                         {'content-type': 'application/json'})


# take in a flask request object and try to parse out a dictionary from the
# request
# try to find if request is as JSON first, then look into forms, finally force
# find it.
# If not found return a dict; else return the parsed data
def parse_request(request):
    if request.json:
        # print 'found in request.json'
        data = request.get_json()

    elif request.data:
        # print 'found in request.data'
        data = json.loads(request.data)

    elif request.form:
        # print 'found in request.form'
        data = request.form.to_dict()
        # try to detect if form contains integers and boolean data and attempt
        # to convert them
        # FIXME: is this a good idea? Fix this to do it in a better way?
        for k in data:
            if is_number(data[k]):
                data[k] = int(data[k])
            if is_bool_in_str(data[k]):
                data[k] = str_to_bool(data[k])

            # print k, data[k]

    else:
        data = request.get_json(force=True)

    if not data:
        return False

    return data


# check if a given string is a number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


# check if in a given string python bool types are represented
def is_bool_in_str(s):
    if s == "True" or s == "False":
        return True
    return False


# convert python bool types in string to native bool types
def str_to_bool(s):
    if s == "True":
        return True
    if s == "False":
        return False
    return None


# decorator to do typechecking of arguments passed to functions
# usage: @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
#        def yourfunc(var1, var2, ..):
#           ....
def typecheck(**typemap):
    """
    Decorator to do typechecking of arguments passed to functions. Similar to
    function annotations in Python 3, but this also does strict type checking
    when a function is called.
    The type to an argument can be single or multiple types. Mutiple types are
    to be specified in a tuple.
    Usage:
        @typecheck(var1=<type>, var2=(<type1>, <type2>), ..)
        def yourfunc(var1, var2, ..):
            ....
    """
    # print "all valid types: %s" % typemap

    def make_wrapper(decorated_func):

        def wrapper(*arg_vals, **kw_vals):
            # TODO: have more comments to better describe each line
            arg_names = decorated_func.func_code.co_varnames
            # print arg_names
            # if not arg_vals:
            #     print kw_vals
            #     # arg_vals = kw_vals
            # print arg_vals

            # iterate over the typemap passed to the typecheck decorator and
            # compare with the actual arguments passed to the function
            for key, val in typemap.iteritems():
                arg_name = key
                idx = arg_names.index(arg_name)
                arg = arg_vals[idx]
                # print "arg_name: %s, arg: %s, typemap[arg_name]: %s" %\
                #    (arg_name, arg, typemap[arg_name])

                # if the passed type is a list throw an error
                if typemap[arg_name] is list:
                    raise SyntaxError("The types of %s has to be a tuple, "
                                      "not list. \n See usage of `typecheck`" %
                                      arg_name)

                # check if the passed type is a tuple, if not make it
                if typemap[arg_name] is not tuple:
                    types = (typemap[arg_name],)
                else:
                    types = typemap[arg_name]

                # iterate over the `types` tuple to see the arg matches any of
                # the type provided in the tuple
                if True not in map(lambda type: isinstance(arg, type), types):
                    # print "types are not fine"
                    raise TypeError("For %s type should have been %s. But "
                                    "provided: %s" % (arg_name,
                                                      typemap[arg_name],
                                                      type(arg)))

            return decorated_func(*arg_vals, **kw_vals)
        return wrapper

    return make_wrapper

#+END_SRC
* Test Cases
** __init__ 
#+BEGIN_SRC python :tangle tests/__init__.py :eval no
#something
print "test package"
#+END_SRC

** Imports and Initialization of testcases

#+BEGIN_SRC python :tangle tests/test_db.py :eval no
# -*- coding: utf-8 -*-

import unittest
from flask.ext.testing import TestCase
# import json

from src.db import *
from src.app import create_app
from src.ds_exceptions import AttributeRequired

config = {
    'SQLALCHEMY_DATABASE_URI': ''
}
#+END_SRC

*** Tests for Custom Types
#+BEGIN_SRC python :tangle tests/test_db.py :eval no

class TestCustomTypes(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    # Test the Name type
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")

    # Test the Email type
    def test_email_type(self):
        print "test_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")

    # Test the URL type
    def test_url_type(self):
        print "test_url_type"
        new_url = URL("http://www.gnu.org/philosophy/")
        # correct URL
        self.assertEqual(new_url.value, "http://www.gnu.org/philosophy/")
        # incorrect URL
        self.assertRaises(TypeError, URL, "@@@@smithgmail.com")

#+END_SRC

*** Tests for Lab
#+BEGIN_SRC python :tangle tests/test_db.py :eval no

class TestLab(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_lab_constructor(self):
        print "test_lab_constructor"
        lab = Lab(name="DS", mnemonic="cse-ds")
        lab.save()
        self.assertEqual(lab.get_name(), "DS")
        # Calling the Lab constructor w/o any arguments should raise
        # AttributeRequired exception
        self.assertRaises(AttributeRequired, Lab)
        # Calling the Lab constructor w/o name, mnemonic arguments should
        # raise AttributeRequired exception
        self.assertRaises(AttributeRequired, Lab,
                          **{'slug': 'ds', 'remarks': 'Completed'})
        # Calling the Lab constructor with required arguments (name, mnemonic)
        # but Type of other arguments are wrong, should raise TypeError
        self.assertRaises(TypeError, Lab,
                          **{'name': 'DS',
                             'mnemonic': 'ds',
                             'integration_level': 6
                             })

    def test_lab_get_id(self):
        print "test_lab_get_id"
        lab = Lab(name="DS", mnemonic="ds")
        lab.save()
        self.assertEqual(lab.get_id(), 1)

    def test_lab_get_lab_by_id(self):
        print "test_lab_get_lab_by_id"
        lab = Lab(name="DS", mnemonic="ds")
        lab.save()
        some_lab = Lab.get_lab_by_id(1)
        self.assertEqual(some_lab, lab)

    def test_lab_get_mnemonic(self):
        print "test_lab_get_mnemonic"
        lab = Lab(name="DS", mnemonic="ds")
        self.assertEqual(lab.get_mnemonic(), "ds")

    def test_lab_get_lab_by_mnemonic(self):
        print "test_lab_get_lab_by_mnemonic"
        lab = Lab(name="DS", mnemonic="ds")
        lab.save()
        some_lab = Lab.get_lab_by_mnemonic("ds")
        self.assertEqual(some_lab, lab)

    def test_lab_get_name(self):
        print "test_lab_get_name"
        lab = Lab(name="DS", mnemonic="ds")
        self.assertEqual(lab.get_name(), "DS")

    def test_lab_get_integration_level(self):
        print "test_lab_get_integration_level"
        ilevel = IntegrationLevel(level=1)
        lab = Lab(name="DS", mnemonic="ds", integration_level=ilevel)
        self.assertEqual(lab.get_integration_level(), 1)

    def test_lab_get_hosted_url(self):
        print "test_lab_get_hosted_url"
        lab = Lab(name="DS", mnemonic="ds", hosted_url=URL("http://gnu.org"))
        self.assertEqual(lab.get_hosted_url(), "http://gnu.org")

    def test_lab_get_repo_url(self):
        print "test_lab_get_repo_url"
        lab = Lab(name="DS", mnemonic="ds", repo_url=URL("http://gnu.org"))
        self.assertEqual(lab.get_repo_url(), "http://gnu.org")

    def test_lab_get_type_of_lab(self):
        print "test_lab_get_type_of_lab"
        lab_type = TypeOfLab(type="Simulation")
        lab = Lab(name="DS", mnemonic="ds", type_of_lab=lab_type)
        self.assertEqual(lab.get_type(), lab_type)

    def test_lab_get_num_of_exps(self):
        print "test_lab_get_num_of_exps"
        exp1 = Experiment(name='Pendulum')
        exp2 = Experiment(name='Gravity')
        exps = [exp1, exp2]
        lab = Lab(name="DS", mnemonic="ds", experiments=exps)
        self.assertEqual(lab.get_num_of_experiments(), 2)

    def test_lab_get_institute(self):
        print "test_lab_get_institute"
        instt = Institute(name="MIT", mnemonic="mit")
        lab = Lab(name="DS", mnemonic="ds", institute=instt)
        self.assertEqual(lab.get_institute().name, "MIT")

    def test_lab_get_developers(self):
        print "test_lab_get_developers"
        dev1 = Developer(name="Joe")
        dev2 = Developer(name="Smith")
        devs = [dev1, dev2]
        lab = Lab(name="DS", mnemonic="ds", developers=devs)
        self.assertItemsEqual(lab.get_developers(), devs)

    def test_lab_get_technologies(self):
        print "test_lab_get_technologies"
        tech1 = Technology(name="php5")
        tech2 = Technology(name="apache2")
        techs = [tech1, tech2]
        lab = Lab(name="DS", mnemonic="ds", technologies=techs)
        self.assertItemsEqual(lab.get_technologies(), techs)

#+END_SRC

*** Tests for Developer
#+BEGIN_SRC 
class TestDeveloper(TestCase):

    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    # Tests for developer entity
    def test_developer(self):
        print "test_developer_creation"
        name = Name("Thirumal Ravula")
        email_id = Email("travula@gmail.com")
        instt = Institute(name="MIT", mnemonic="mit")
        developer = Developer(name=name, email_id=email_id, institute=instt)
        self.assertEqual(developer.name, name)
#+END_SRC   

*** Tests for Institute
#+BEGIN_SRC 
class TestInstitute(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_set_institute_pic(self):
        print "test_set_institute_pic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="Avinash", iic="Amit")
        new_pic = Name("John Doe")
        instt.set_pic(new_pic)
        self.assertEqual(instt.pic, "John Doe")

    def test_set_institute_iic(self):
        print "test_set_institute_iic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Amit")
        new_iic = Name("Jane Doe")
        # print new_iic
        instt.set_iic(new_iic)
        self.assertEqual(instt.iic, "Jane Doe")

    def test_set_institute_name(self):
        print "test_set_institute_name"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Amit")
        new_name = InstituteName("IIT-Hyd Telangana")
        instt.set_name(new_name)
        self.assertEqual(instt.name, "IIT-Hyd Telangana")

    def test_get_institute_name(self):
        print "test_get_institute_name"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        inst_name = instt.get_name()
        self.assertEqual(inst_name, "IndianInstitute")

    def test_get_institute_mnemonic(self):
        print "test_get_institute_mnemonic"
        instt = Institute(name="MIT", mnemonic="mit")
        self.assertEqual(instt.get_mnemonic(), "mit")

    def test_get_institute_pic(self):
        print "test_get_institute_pic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        inst_pic = instt.get_pic()
        self.assertEqual(inst_pic, "John")

    def test_get_institute_iic(self):
        print "test_get_institute_iic"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        inst_iic = instt.get_iic()
        self.assertEqual(inst_iic, "Jane")

    def test_get_id_of_institute(self):
        print "test_get_id_of_institute"
        instt = Institute(id="1", name="SomeInstitute", mnemonic="si")
        institute_id = instt.get_id()
        self.assertEqual(institute_id, "1")

    def test_get_institute_by_id(self):
        print "test_get_institute_by_id"
        instt = Institute(name="IndianInstitute", mnemonic="ii",
                          pic="John", iic="Jane")
        instt.save()
        self.assertEqual(instt.get_institute_by_id(1).name, "IndianInstitute")

    def test_get_institute_by_mnemonic(self):
        print "test_get_institute_by_mnemonic"
        instt = Institute(name="MIT", mnemonic="mit")
        instt.save()
        some_instt = Institute.get_institute_by_mnemonic("mit")
        self.assertEqual(some_instt, instt)

    def test_get_institute_labs(self):
        print "test_get_institute_labs"
        lab1 = Lab(name="Micro Controllers", mnemonic="micro")
        lab2 = Lab(name="Digital Logic Design", mnemonic="digital")
        labs = [lab1, lab2]
        instt = Institute(name="MIT", mnemonic="mit", labs=labs)
        self.assertItemsEqual(instt.get_labs(), labs)

#+END_SRC        

*** Tests for Discipline
#+BEGIN_SRC 
class TestDiscipline(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_set_discipline_dnc(self):
        print "test_set_discipline_dnc"
        disc = Discipline(name="CSE", mnemonic="cs")
        new_dnc = Name("James roy")
        disc.set_dnc(new_dnc)
        self.assertEqual(disc.dnc, "James roy")
        self.assertRaises(TypeError, disc.set_dnc, "123 James roy")

    def test_set_discipline_name(self):
        print "test_set_discipline_name"
        disc = Discipline(name="Electronics & Communication", mnemonic="ece")
        new_disc = Name("Electronics & Communication Engineering")
        disc.set_name(new_name)
        self.assertEqual(disc.name, "Electronics & Communication Engineering")

    def test_get_discipline_id(self):
        print "test_get_discipline_id"
        disc = Discipline(name="CSE", mnemonic="cs")
        disc.save()
        self.assertEqual(disc.id, disc.get_id())

    def test_get_discipline_name(self):
        print "test_get_discipline_name"
        disc = Discipline(name="CSE", mnemonic="cs")
        disc.save()
        self.assertEqual(disc.get_name(), "CSE")

    def test_get_discipline_dnc(self):
        print "test_get_discipline_dnc"
        disc = Discipline(name="CSE", mnemonic="cs", dnc="James")
        self.assertEqual(disc.get_dnc(), "James")

    def test_get_discipline_mnemonic(self):
        print "test_get_discipline_mnemonic"
        disc = Discipline(name="CSE", mnemonic="cs", dnc="James")
        self.assertEqual(disc.get_mnemonic(), "cs")

    def test_get_discipline_by_id(self):
        print "test_get_discipline_name"
        disc = Discipline(name="CSE", mnemonic="cs", dnc="James")
        disc.save()
        self.assertEqual(disc.get_discipline_by_id(1).name, disc.name)

    def test_get_discipline_by_mnemonic(self):
        print "test_get_discipline_by_mnemonic"
        disc = Discipline(name="Computer Science", mnemonic="cse")
        disc.save()
        some_disc = Discipline.get_discipline_by_mnemonic("cse")
        self.assertEqual(some_disc, disc)

    def test_get_discipline_labs(self):
        print "test_get_discipline_labs"
        lab1 = Lab(name="Micro Controllers", mnemonic="micro")
        lab2 = Lab(name="Digital Logic Design", mnemonic="digital")
        labs = [lab1, lab2]
        disc = Discipline(name="Electronics", mnemonic="ece", labs=labs)
        self.assertItemsEqual(disc.get_labs(), labs)

#+END_SRC

#+BEGIN_SRC python :tangle tests/test_db.py :eval no

if __name__ == '__main__':
    unittest.main()

#+END_SRC

** APP.py
#+BEGIN_SRC python :tangle src/app.py :eval no
# -*- coding: utf-8 -*-

import os
import logging
from logging.handlers import RotatingFileHandler

from flask import Flask, jsonify, make_response
from flask.ext.cors import CORS

from db import db
# import config file
import config


def create_app(config):
    # init our app
    app = Flask(__name__)

    # load config values from the config file
    app.config.from_object(config)

    # init sqlalchemy db instance
    db.init_app(app)
    db.app = app

    # register blueprints
#    app.register_blueprint(api)

    configure_errorhandlers(app)
    configure_cors(app)
    configure_logging(app)

    # all set; return app object
    return app


# configure cross origin resource sharing
def configure_cors(app):
    # CORS(app)
    CORS(app, origins=config.ALLOWED_ORIGINS,
         methods=['GET', 'OPTIONS', 'PUT', 'POST'],
         allow_headers='Content-Type')


# custom error handlers to return JSON errors with appropiate status codes
def configure_errorhandlers(app):

    @app.errorhandler(404)
    def not_found(err):
        if 'description' not in err:
            return make_response(jsonify(error='No such URL found'), 404)

        return make_response(jsonify(error=err.description), 404)

    @app.errorhandler(400)
    def bad_request(err):
        return make_response(jsonify(error=err.description), 400)


def configure_logging(app):
    formatter = logging.Formatter('%(asctime)s: %(levelname)s: %(filename)s:'
                                  ' %(funcName)s():%(lineno)d: %(message)s')

    if 'LOG_FILE' in app.config:
        log_filename = app.config['LOG_FILE']
    else:
        log_filename = 'dataservice.log'
    # Also error can be sent out via email. So we can also have a SMTPHandler?
    log_file = os.path.join(os.path.dirname(__file__), '..', log_filename)

    max_size = 1024 * 1024 * 20  # Max Size for a log file: 20MB
    log_handler = RotatingFileHandler(log_file, maxBytes=max_size,
                                      backupCount=10)

    if 'LOG_LEVEL' in app.config:
        log_level = app.config['LOG_LEVEL'] or 'ERROR'
    else:
        log_level = 'ERROR'

    log_handler.setLevel(log_level)
    log_handler.setFormatter(formatter)

    app.logger.addHandler(log_handler)


if __name__ == "__main__":
    app = create_app(config)
    app.run(debug=True, host='0.0.0.0')

#+END_SRC
   
** Config
#+BEGIN_SRC python :tangle src/config.py :eval no
# DB URI
# example DB URI:
# mysql+oursql://scott:tiger@localhost/mydatabase
# postgresql+psycopg2://scott:tiger@localhost/mydatabase
SQLALCHEMY_DATABASE_URI =\
    'mysql+oursql://root:root@localhost/dataservice'

# Debug from SQLAlchemy
# Turn this to False on production
SQLALCHEMY_ECHO = False

# List of allowed origins for CORS
ALLOWED_ORIGINS = ["*"]

# Configure your log paths
LOG_FILE = 'logs/dataservice.log'

# Log level for the application
LOG_LEVEL = 'ERROR'

#+END_SRC
* Provisioning
  [[./setup.org][Set up the environment]]
* Design discussions
* Releases
** v0.1.0
    This release will satisfy requirements 1 & 2
    Release Date :: [2015-08-26 Wed]
*** Work Split
**** Overview
     #+CAPTION: Total Hours
     #+NAME:    total-hours

     |------------------+------------------+--------+--------+--------|
     |                  |                  |        |        | Total  |
     |                  |                  | No. of | No. of | number |
     | Start Date       | End Date         | days   | people | of     |
     |                  |                  |        |        | person |
     |                  |                  |        |        | days   |
     |------------------+------------------+--------+--------+--------|
     | [2015-08-13 Thu] | [2015-08-26 Wed] | 10     | 5      | 50     |
     |------------------+------------------+--------+--------+--------|

**** Detailed
     #+CAPTION: Detailed Hours
     #+NAME:    detailed-hours

     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Task Name            |                  | Date of Completion |                         |      |           Effort |
     |                      | Start Date       |                    | no.                     |  no. | (in person days) |
     |                      |                  |                    | of                      |   of |                  |
     |                      |                  |                    | persons                 | days |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Data Model           | [2015-08-13 Thu] | [2015-08-18 Tue]   | 1                       |    4 |                4 |
     | (Initial Cut)        |                  |                    |                         |      |                  |
     |                      |                  |                    |                         |      |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Python API           |                  |                    |                         |      |                  |
     | & REST API           | [2015-08-19 Wed] | [2015-08-26 Wed]   | 2                       |    6 |               12 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | VIEW -               |                  |                    | 4 till [2015-08-18 Tue] |    4 |               16 |
     | list, detail         | [2015-08-13 Thu] | [2015-08-26 Wed]   |                         |      |                  |
     | and update           |                  |                    |                         |      |                  |
     |                      |                  |                    | 2 till [2015-08-26 Wed] |    6 |               12 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Provisioning &       |                  |                    |                         |      |                  |
     | Data Model Evolution | [2015-08-19 Wed] | [2015-08-26 Wed]   | 1                       |    6 |                6 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Filters              |                  |                    |                         |      |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|

*** Tasks & Deadlines
    1. Data Model
       + Completion Date :: [2015-08-18 Tue]
       + Effort :: 3 person days
       + Tasks
         - Describe each entity and capture the model of data for each entity.
         - Describe the relationship between all the entities.
    2. Python API , REST API and Migration scripts from old data to new model
       + Completion Data :: [2015-08-26 Wed]
       + Effort :: 12 person days
       + Tasks
         - Provide Python API to perform CRUD operations on different entities.
         - Provide REST API for different application to perform CRUD
           operations on different entities.
         - Provide a migration script that converts the legacy data into the
           new data model.
    3. VIEW - list, detail and update views of each entity
       + Completion Data :: [2015-08-26 Wed]
       + Effort :: 12 person days
       + Tasks
         - Provide a mechanism to list all the rows in an entity for all entities.
         - Provide a mechanism to a detailed view of a row in a selected entity.
         - Provide a mechanism to update a row in an entity.

    4. Filters

    5. Provisioning

