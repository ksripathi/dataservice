#+TITLE: Dataservice
#+Author: VLEAD
#+Date: [2015-08-13 Thu]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org

* Introduction
  Dataservice is a micro service that allows persistence of data by other micro
  services over HTTP using REST API.  dataservie hides the implementation
  details of the data store that is required for data persistence.

* Requirements
  1. The model of the data on whose foundation dataservice is built is
     explicitly laid out. <<req1>>
  2. Python API is provided as a wrapper to make CRUD operations on the data.
  3. REST API is provided for various applications to perform CRUD operations
     on the data.

* Design & Implementation

** Data Model
Description of the data model.

*** Types & Functions: List of all the types and functions in the model

**** Lab

***** Immutable Data
      
These are the data associated with Lab type, which are immutable.

+ LabId
+ Mnemonic
+ NoOfExperiments

  As the number of experiments should be derived by the system from the
  experiments already associated with each lab.

***** Mutable Data
These are the data associated with Lab type, which are mutable.

+ Name
+ Institute
+ Discipline
+ IntegrationLevel
+ HostedURL
+ RepoURL
+ TypeOfLab
+ HostedOn
+ Web2Compliant
+ Phase2Lab
+ Developer
+ Technology
+ Experiment

***** TODO: Mnemonic assigned for each lab

#+BEGIN_SRC 
class Lab(Entity):

    __tablename__ = 'labs'

    id = db.Column(db.Integer, primary_key=True)

    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    slug = db.Column(db.String(128))

    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))
    discipline_id = db.Column(db.Integer, db.ForeignKey('disciplines.id'))

    integration_level_id = db.Column(db.ForeignKey('integration_levels.id'))

    developers = db.relationship('Developer', secondary=developers_engaged,
                                 backref='labs')

    number_of_experiments = db.Column(db.Integer)

    experiments = db.relationship('Experiment', backref='lab')

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_labs,
                                   backref='labs')

    repo_url = db.Column(db.String(256))

    hosted_url = db.Column(db.String(256))

    hosted_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))

    type_of_lab_id = db.Column(db.ForeignKey('type_of_labs.id'))

    remarks = db.Column(db.Text)
    status = db.Column(db.String(32))

    is_web_2_compliant = db.Column(db.Boolean)
    is_phase_2_lab = db.Column(db.Boolean)
#+END_SRC
      

**** Functions that operate on the Lab domain
***** getId: Lab --> LabId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

***** getLab: LabId --> Lab
#+BEGIN_SRC 
    @staticmethod
    def get_lab_by_id(id):
        return Lab.query.get(id)
#+END_SRC

***** getAllLabs: Nil --> set[Lab]
#+BEGIN_SRC 
    @staticmethod
    def get_all(fields=None):
        # get all labs from db
        labs = [i.to_client() for i in Lab.query.all()]
        print 'total count of labs'
        print len(labs)
        # print fields
        # if request do not contain fields, return the data
        if not fields:
            return labs
        # if fields exist in the request, format all the labs to have only the
        # fields requested by the user
        formatted_labs = Lab.format_labs_by_fields(labs, fields)
        return formatted_labs
#+END_SRC

***** getMnemonic: Lab --> Mnemonic
#+BEGIN_SRC 
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

***** getLab: Mnemonic --> Lab
#+BEGIN_SRC 
    @staticmethod
    def get_lab_by_mnemonic(mnemonic):
        return Lab.query.filter_by(mnemonic=mnemonic).first()
#+END_SRC

***** getName: Lab --> Name

       This is similar to the =getId= function and all types will have this
       function.
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

***** getIntegrationLevel: Lab --> Level
#+BEGIN_SRC 
    def get_integration_level(self):
        return self.integration_level.level
#+END_SRC

***** getHostedURL: Lab --> Nil + URL

       URL: when hosted

       Nil: when not hosted
#+BEGIN_SRC 
    def get_hosted_url(self):
        return self.hosted_url
#+END_SRC
       
***** getRepoURL: Lab --> Nil + URL

       URL: when sources are available

       Nil: otherwise
#+BEGIN_SRC 
    def get_repo_url(self):
        return self.repo_url
#+END_SRC

***** getType: Lab --> TypeOfLab
#+BEGIN_SRC 
    def get_type(self):
        return self.type_of_lab
#+END_SRC

***** getNoOfExperiments: Lab --> Nat
#+BEGIN_SRC 
    def get_num_of_experiments(self):
        return len(self.experiments)
#+END_SRC

***** getHostedOn: Lab --> HostingPlatform + Nil
#+BEGIN_SRC 
    def get_hosted_on(self):
        return self.hosted_on
#+END_SRC

***** isWeb2Compliant: Lab --> Boolean
#+BEGIN_SRC 
    def is_web_2_compliant(self):
        return self.is_web_2_compliant
#+END_SRC

***** isPhase2Lab: Lab --> Boolean
#+BEGIN_SRC 
    def is_phase_2(self):
        return self.is_phase_2_lab
#+END_SRC

***** getDiscipline: Lab --> Discipline
#+BEGIN_SRC 
    def get_discipline(self):
        return self.discipline
#+END_SRC

***** getExperiments: Lab --> set[Experiment]
#+BEGIN_SRC 
    def get_experiments(self):
        return self.experiments
#+END_SRC

***** getInstitute: Lab --> Institute
#+BEGIN_SRC 
    def get_institute(self):
        return self.institute
#+END_SRC

***** getDevelopers: Lab --> set[Developer]
#+BEGIN_SRC 
    def get_developers(self):
        return self.developers
#+END_SRC

***** getTechnologies: Lab --> set[Technology]
#+BEGIN_SRC 
    def get_technologies(self):
        return self.technologies
#+END_SRC

***** setName: Lab, Name --> Void

       NOTE: All types will have a =setName= function.
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name
        self.save()
#+END_SRC

***** setInstitute: Lab, Institute --> Void
#+BEGIN_SRC 
    @typecheck(institute=Institute)
    def set_institute(self, institute):
        self.institute = institute
        self.save()
#+END_SRC

***** setDiscipline: Lab, Discipline --> Void
#+BEGIN_SRC 
    @typecheck(discipline=Discipline)
    def set_discipline(self, discipline):
        self.discipline = discipline
        self.save()
#+END_SRC

***** setIntegrationLevel: Lab, Level --> Void
#+BEGIN_SRC 
    @typecheck(level=IntegrationLevel)
    def set_integration_level(self, level):
        self.integration_level = level
        self.save()
#+END_SRC

***** setHostedURL: Lab, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_hosted_url(self, url):
        self.hosted_url = url
        self.save()
#+END_SRC

***** setRepoURL: Lab, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_repo_url(self, url):
        self.repo_url = url
        self.save()
#+END_SRC

***** setTypeOfLab: Lab, TypeOfLab --> Void
#+BEGIN_SRC 
    @typecheck(type=TypeOfLab)
    def set_type_of_lab(self, type):
        self.type_of_lab = type
        self.save()
#+END_SRC

***** setHostedOn: Lab, HostingPlatform --> Void
#+BEGIN_SRC 
    @typecheck(platform=HostingPlatform)
    def set_hosted_on(self, platform):
        self.hosted_on = platform
        self.save()
#+END_SRC

***** setisWeb2Compliant: Lab, Boolean --> Void
#+BEGIN_SRC 
    @typecheck(compliant=bool)
    def set_is_web_2_compliant(self, compliant):
        self.is_web_2_compliant = compliant
        self.save()
#+END_SRC

***** setisPhase2: Lab, Boolean --> Void
#+BEGIN_SRC 
    @typecheck(phase2=bool)
    def set_is_phase_2_lab(self, phase2):
        self.is_phase_2_lab = phase2
        self.save()
#+END_SRC

***** addDeveloper: Lab, Developer --> Void
#+BEGIN_SRC 
    @typecheck(developer=Developer)
    def add_developer(self, developer):
        self.developers.append(developer)
        self.save()
#+END_SRC

***** removeDeveloper: Lab, Developer --> Void
#+BEGIN_SRC 
    @typecheck(developer=Developer)
    def remove_developer(self, developer):
        if developer in self.developers:
            self.developers.remove(developer)
            self.save()
#+END_SRC

***** addTechnology: Lab, Technology --> Void
#+BEGIN_SRC 
    @typecheck(technology=Technology)
    def add_technology(self, technology):
        self.technologies.append(technology)
        self.save()
#+END_SRC

***** removeTechnology: Lab, Technology --> Void
#+BEGIN_SRC 
    @typecheck(technology=Technology)
    def remove_technology(self, technology):
        if technology in self.technologies:
            self.technologies.remove(technology)
            self.save()
#+END_SRC

***** addExperiment: Lab, Experiment --> Void
#+BEGIN_SRC 
    @typecheck(experiment=Experiment)
    def add_experiment(self, experiment):
        self.experiments.append(experiment)
        self.save()
#+END_SRC

***** removeExperiment: Lab, Experiment --> Void
#+BEGIN_SRC 
    @typecheck(experiment=Experiment)
    def remove_experiment(self, experiment):
        if experiment in self.experiments:
            self.experiments.remove(experiment)
            self.save()
#+END_SRC

***** formatLabsByFields
#+BEGIN_SRC 
    @staticmethod
    def format_labs_by_fields(labs, fields):
        current_app.logger.debug("labs recvd: %s" % labs)
        formatted_labs = []  # all labs
        for lab in labs:
            formatted_lab = {}  # formatted lab
            for field in fields:
                try:
                    formatted_lab[field] = lab[field]
                except KeyError:
                    raise Exception('Invalid field %s', field)

            # print fmttd_lab
            formatted_labs.append(formatted_lab)
        return formatted_labs
#+END_SRC

***** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'mnemonic': self.mnemonic,
            'name': self.name,
            'slug': self.slug,
            'institute': self.institute.to_client(),
            'discipline': self.discipline.to_client(),
            'integration_level': self.integration_level,
            'number_of_experiments': self.number_of_experiments,
            'repo_url': self.repo_url,
            'hosted_url': self.hosted_url,
            'hosted_on': self.hosted_on,
            'technologies': self.technologies,
            'developers': self.developers,
            'type_of_lab': self.type_of_lab,
            'status': self.status,
            'is_web_2_compliant': self.is_web_2_compliant,
            'is_phase_2_lab': self.is_phase_2_lab,
            'remarks': self.remarks
        }
#+END_SRC

**** Institute

***** Immutable Data
This is the data associated with Institute type, which is immutable.

+ InstituteId
+ Mnemonic

***** Mutable Data

These are the data associated with Institute type, which are mutable

+ PIC
+ IIC

***** Mnemonic assigned to each institute
|---------------------------------+----------|
| Name                            | Mnemonic |
|---------------------------------+----------|
| IIIT Hyderabad                  | iiith    |
| IIT Bombay                      | iitb     |
| IIT Delhi                       | iitd     |
| IIT Roorkee                     | iitrrk   |
| IIT Guwahati                    | iitg     |
| IIT Kanpur                      | iitk     |
| IIT Kharagpur                   | iitkgp   |
| IIT Madras                      | iitm     |
| NIT Surathkal                   | nitk     |
| Amrita University               | amrita   |
| College of Engineering, Pune    | coep     |
| Dayalbagh Educational Institute | dei      |
|---------------------------------+----------|

#+BEGIN_SRC 
class Institute(Entity):

    __tablename__ = 'institutes'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    pic = db.Column(db.String(128))
    iic = db.Column(db.String(128))

    labs = db.relationship('Lab', backref='institute')
    developers = db.relationship('Developer', backref='institute')
#+END_SRC

**** Functions that operate on Institute domain

***** getId: Institute --> InstituteId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

***** getName: Institute --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

***** getInstitute: InstituteId --> Institute
#+BEGIN_SRC 
    @staticmethod
    def get_institute_by_id(id):
        return Institute.query.get(id)
#+END_SRC

***** getMnemonic: Institute --> Mnemonic
#+BEGIN_SRC 
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

***** getInstitute: Mnemonic --> Institute
#+BEGIN_SRC 

#+END_SRC

***** getPIC: Institute --> Name
#+BEGIN_SRC 
    def get_pic(self):
        return self.pic
#+END_SRC
      
***** getIIC: Institute --> Name
#+BEGIN_SRC 
    def get_iic(self):
        return self.iic
#+END_SRC

***** getLabs: Institute --> set[Lab]
#+BEGIN_SRC 
    def get_labs(self):
        return self.labs
#+END_SRC

***** getDevelopers: Institute --> set[Developer]
#+BEGIN_SRC 
    def get_developers(self):
        return self.developers
#+END_SRC

***** getAllInstitutes: Nil --> set[Institute]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Institute.query.all()]
#+END_SRC

***** setPIC: Institute, Name --> Void
#+BEGIN_SRC 
    @typecheck(pic=Name)
    def set_pic(self, pic):
        self.pic = pic.value
#+END_SRC

***** setIIC: Institute, Name --> Void
#+BEGIN_SRC 
    @typecheck(iic=Name)
    def set_iic(self, iic):
        self.iic = iic.value
#+END_SRC
      
***** setName: Institute, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=InstituteName)
    def set_name(self, name):
        self.name = name.value
#+END_SRC


***** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'mnemonic': self.mnemonic,
            'pic': self.pic,
            'iic': self.iic
        }
#+END_SRC

**** Discipline

***** Immutable Data
This is the data associated with Discipline type, which is immutable.

+ DisciplineId
+ Mnemonic

***** Mutable Data
This is the data associated with Discipline type, which is mutable.

+ DNC

***** Mnemonic assigned to each discipline
|------------------------------------------+-----------|
| Name                                     | Mnemonic  |
|------------------------------------------+-----------|
| Aerospace Engineering                    | aero      |
| Biotechnology and Biomedical Engineering | biotech   |
| Chemical Engineering                     | chem-engg |
| Chemical Sciences                        | chem      |
| Civil Engineering                        | civil     |
| Computer Science and Engineering         | cse       |
| Electrical Engineering                   | ee        |
| Electronics and Communication            | ece       |
| Humanities                               | human     |
| Mechanical Engineering                   | mech      |
| Physical Sciences                        | phy-sc    |
| Textile Engineering                      | tex-engg  |
| Design Engineering                       | dsgn-engg |
| Material Sciences                        | mat-sc    |
|------------------------------------------+-----------|

#+BEGIN_SRC 
class Discipline(Entity):

    __tablename__ = 'disciplines'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), nullable=False)
    mnemonic = db.Column(db.String(16), nullable=False)
    dnc = db.Column(db.String(64))

    labs = db.relationship('Lab', backref='discipline')
#+END_SRC


**** Functions that operate on Discipline domain
***** getAllDisciplines: Nil --> set[Discipline]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Discipline.query.all()]
#+END_SRC

***** getId: Discipline --> DisciplineId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

***** getName: Discipline --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC
***** getDiscipline: DisciplineId --> Discipline
#+BEGIN_SRC 
    def get_discipline_by_id(id):
        return Discipline.query.get(id)
#+END_SRC

***** getMnemonic: Discipline --> Mnemonic
#+BEGIN_SRC 
    def get_mnemonic(self):
        return self.mnemonic
#+END_SRC

***** getDiscipline: Mnemonic --> Discipline
#+BEGIN_SRC 

#+END_SRC

***** getLabs: Discipline --> set[Lab]
#+BEGIN_SRC 
    def get_labs(self):
        return self.labs
#+END_SRC

***** getDNC: Discipline --> Name
#+BEGIN_SRC 
    def get_dnc(self):
        return self.dnc
#+END_SRC

***** setName: Discipline --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC

***** setDNC: Discipline, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC      

***** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'mnemonic': self.mnemonic,
            'dnc': self.dnc
        }
#+END_SRC

**** Experiment

***** Immutable Data
This is the data associated with Experiment type, which is immutable.

+ ExperimentId

***** Mutable Data
These are the data associated with Discipline type, which are mutable.

+ ContentURL
+ SimulationURL
+ ContentHostedOn
+ SimulationHostedOn

#+BEGIN_SRC 
class Experiment(Entity):

    __tablename__ = 'experiments'

    id = db.Column(db.Integer, primary_key=True)

    # Our data set has really, really long experiment names and URLs!!
    name = db.Column(db.String(256))

    lab_id = db.Column(db.Integer, db.ForeignKey('labs.id'))

    content_url = db.Column(db.String(256))
    # content_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    content_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    content_on = db.relationship('HostingPlatform',
                                 foreign_keys=[content_on_id])

    simulation_url = db.Column(db.String(256))
    # simulation_on = db.Column(db.Enum('CPE', 'ELSE', 'NA'))
    simulation_on_id = db.Column(db.ForeignKey('hosting_platforms.id'))
    simulation_on = db.relationship('HostingPlatform',
                                    foreign_keys=[simulation_on_id])

    technologies = db.relationship('Technology',
                                   secondary=technologies_used_expt,
                                   backref='experiments')
#+END_SRC

Following is the constructor for this class.

#+BEGIN_SRC 
    @typecheck(lab=Lab, content_url=URL, content_hosted_on=HostingPlatform,
               simulation_url=URL, simulation_hosted_on=HostingPlatform)
    def __init__(self, **kwargs):
        # TODO: implement the constructor and check the validity!
        pass
#+END_SRC

**** Functions that operate on the Experiment domain

***** getId: Experiment --> ExperimentId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

***** getExperiment: ExperimentId --> Experiment
#+BEGIN_SRC 
    @staticmethod
    def get_experiment(id):
        return Experiment.query.get(id)
#+END_SRC

***** getContentURL: Experiment --> URL + Nil
#+BEGIN_SRC 
    def get_content_url(self):
        return self.content_url
#+END_SRC

***** getSimulationURL: Experiment --> URL + Nil
#+BEGIN_SRC 
    def get_simulation_url(self):
        return self.simulation_url
#+END_SRC

***** getTechnologies: Experiment --> set[Technology]
#+BEGIN_SRC 

#+END_SRC

***** contentHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC 
    def content_hosted_on(self):
        return self.content_hosted_on
#+END_SRC

***** simulationHostedOn: Experiment --> HostingPlatform + Nil
#+BEGIN_SRC 
    def simulation_hosted_on(self):
        return self.simulation_hosted_on
#+END_SRC

***** getLab: Experiment --> Lab
#+BEGIN_SRC 
    def get_lab(self):
        return self.lab
#+END_SRC

***** setContentURL: Experiment, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_content_url(self, url):
        self.content_url = url
        self.save()
#+END_SRC

***** setSimulationURL: Experiment, URL --> Void
#+BEGIN_SRC 
    @typecheck(url=URL)
    def set_simulation_url(self, url):
        self.simulation_url = url
        self.save()
#+END_SRC

***** setContentHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC 
    @typecheck(platform=HostingPlatform)
    def set_content_hosted_on(self, platform):
        self.content_hosted_on = platform
        self.save()
#+END_SRC

***** setSimulationHostedOn: Experiment, HostingPlatform --> Void
#+BEGIN_SRC 
    @typecheck(platform=HostingPlatform)
    def set_simulation_hosted_on(self, platform):
        self.simulation_hosted_on = platform
        self.save()
#+END_SRC

***** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'content_url': self.content_url,
            'content_on': self.content_on,
            'simulation_url': self.simulation_url,
            'simulation_on': self.simulation_on,
            'lab': self.lab.to_client()
        }
#+END_SRC

**** Developer

***** Immutable Data
This is the data associated with Developer type, which is immutable.

+ DeveloperId

***** Mutable Data
This is the data associated with Developer type, which is mutable.

+ Email

#+BEGIN_SRC 
class Developer(Entity):

    __tablename__ = 'developers'

    id = db.Column(db.Integer, primary_key=True)

    email_id = db.Column(db.String(128))
    name = db.Column(db.String(64), nullable=False)

    institute_id = db.Column(db.Integer, db.ForeignKey('institutes.id'))
#+END_SRC


**** Functions that operate on the Developer domain
***** getId: Developer --> DeveloperId
#+BEGIN_SRC 
    def get_id(self):
        return self.id
#+END_SRC

***** getName: Developer --> Name
#+BEGIN_SRC 
    def get_name(self):
        return self.name
#+END_SRC

***** getAllDevelopers: Nil --> set[Developer]
#+BEGIN_SRC 
    @staticmethod
    def get_developer(id):
        return Developer.query.get(id)
#+END_SRC

***** getLabs: Developer --> set[Lab]
#+BEGIN_SRC 

#+END_SRC

***** getInstitute: Developer --> Institute
#+BEGIN_SRC 

#+END_SRC

***** getDeveloper: DeveloperId --> Developer
#+BEGIN_SRC 
    def get_developer(id):
        return Developer.query.get(id)
#+END_SRC

***** getEmail: Developer --> Email
#+BEGIN_SRC 
    def get_email(self):
        return self.email_id
#+END_SRC

***** setName: Developer, Name --> Void
#+BEGIN_SRC 
    @typecheck(name=Name)
    def set_name(self, name):
        self.name = name.value
#+END_SRC

***** setEmail: Developer, Email --> Void
#+BEGIN_SRC 
    @typecheck(email_id=Email)
    def set_email(self, email_id):
        self.email_id = email_id.value
#+END_SRC

***** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'email_id': self.email_id,
            'name': self.name,
            'institute': self.institute.to_client()
        }
#+END_SRC

**** Technology

***** Immutable Data
This is the data associated with Technology type, which is immutable.

+ TechnologyId

***** Mutable Data
These are the data associated with Technoloy type, which are mutable.

+ Version
+ FOSS

#+BEGIN_SRC 
class Technology(Entity):

    __tablename__ = 'technologies'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), nullable=False)
    version = db.Column(db.String(32))
    foss = db.Column(db.Boolean)
#+END_SRC

**** Functions that operate on the Technology domain
***** getId: Technology --> TechnologyId

***** getAllTechnologies: Nil --> set[Technology]
#+BEGIN_SRC 
    @staticmethod
    def get_all():
        return [i.to_client() for i in Technology.query.all()]
#+END_SRC

***** getLabs: Technology --> set[Lab]
#+BEGIN_SRC 

#+END_SRC

***** getTechnology: TechnologyId --> Technology

***** getVersion: Technology --> Version

***** isFOSS: Technology --> Boolean

***** setVersion: Technology, Version --> Void

***** setFOSS: Technology, Boolean --> Void

***** to_client
#+BEGIN_SRC 
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'version': self.version,
            'foss': self.foss
        }
#+END_SRC

**** HostingPlatform

   HostingPlatform is {IIIT, Badal, AWS, Else}.

#+BEGIN_SRC 
class HostingPlatform(Entity):
    __tablename__ = 'hosting_platforms'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(32), nullable=False)

    labs = db.relationship('Lab', backref='hosted_on')
#+END_SRC
**** Version

   Version is an alphanumeric string including '-' and '.'.

#+BEGIN_SRC 
class Version(object):
    pass
#+END_SRC
**** URL

   URL is a type as defined in RFC 1738.

#+BEGIN_SRC 
class URL(object):
    pass
#+END_SRC
**** Name

   Name is an alphabetical string.
   Following is the constructor for this class.

#+BEGIN_SRC 
class Name(object):
    def __init__(self, value):
        # if the string contains any non-alphabet and non-space character, raise
        # a type error
        if re.search('[^a-zA-Z ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC

**** InstituteName
    
     InstituteName is an alphabetical string including a '-'.
     Following is the constructor for this class.

#+BEGIN_SRC 
class InstituteName(object):
    def __init__(self, value):
        # if the string contains any non-alphabet, non-hyphen and non-space
        # character, raise a type error
        if re.search('[^a-zA-Z\- ]+', value):
            raise TypeError('%s is not a Name!' % value)

        self.value = value
#+END_SRC
     
**** LabId

   LabId is a natural number.

**** InstituteId

   InstituteId is a natural number.

**** DisciplineId

   DisciplineId is a natural number.

**** DeveloperId
     
   DeveloperId is a natural number.

**** ExperimentId

   ExperimentId is a natural number.

**** TechnologyId

   TechnologyId is a natural number.

**** Email

   Email is a type as defined in RFC 5321, 5322 and 6531.
   Following is the constructor for this class.

#+BEGIN_SRC 
class Email(object):
    def __init__(self, value):
        if not re.search('[^@]+@[^@]+\.[^@]+', value):
            raise TypeError('%s is not an email_id!' % value)
        self.value = value
#+END_SRC
**** TypeOfLab

   TypeOfLab is { Simulation,
                 Remote Triggered,
                 Simulation and Remote Triggered,
                 Pilot Phase }

#+BEGIN_SRC 
class TypeOfLab(Entity):
    __tablename__ = 'type_of_labs'
    id = db.Column(db.Integer, primary_key=True)
    type = db.Column(db.String(64), nullable=False)

    labs = db.relationship('Lab', backref='type_of_lab')
#+END_SRC
**** IntegrationLevel
      
   IntegrationLevel is {L0, L1, L2, L3, L4, L5, L6}.

#+BEGIN_SRC 
class IntegrationLevel(Entity):
    __tablename__ = 'integration_levels'
    id = db.Column(db.Integer, primary_key=True)
    level = db.Column(db.Integer, nullable=False)

    labs = db.relationship('Lab', backref='integration_level')
#+END_SRC
    
*** Functions operating on multiple domains
     
***** NOTE: is it necessary? getAllLabs: Nil --> set[Lab]

***** NOTE: is it necessary? getAllDevelopers: Nil --> set[Developer]

***** NOTE: is it necessary? getAllExperiments: Nil --> set[Experiment]


*** Relationship between different entities
  #+CAPTION: Entity Diagram
  #+NAME:   entity
  [[https://drive.google.com/open?id%3D0B6LLRcwXMzt8N3RzZGVkb0NpUDA][ER-Diagram]]

* Test Cases
* Design discussions
* Releases
** v0.1.0
    This release will satisfy requirements 1, 2 and 3
*** Work Split
**** Overview
     #+CAPTION: Total Hours
     #+NAME:    total-hours

     |------------------+------------------+--------+--------+--------|
     |                  |                  |        |        | Total  |
     |                  |                  | No. of | No. of | number |
     | Start Date       | End Date         | days   | people | of     |
     |                  |                  |        |        | person |
     |                  |                  |        |        | days   |
     |------------------+------------------+--------+--------+--------|
     | [2015-08-13 Thu] | [2015-08-26 Wed] | 10     | 5      | 50     |
     |------------------+------------------+--------+--------+--------|

**** Detailed
     #+CAPTION: Detailed Hours
     #+NAME:    detailed-hours

     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Task Name            |                  | Date of Completion |                         |      |           Effort |
     |                      | Start Date       |                    | no.                     |  no. | (in person days) |
     |                      |                  |                    | of                      |   of |                  |
     |                      |                  |                    | persons                 | days |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Data Model           | [2015-08-13 Thu] | [2015-08-18 Tue]   | 1                       |    4 |                4 |
     | (Initial Cut)        |                  |                    |                         |      |                  |
     |                      |                  |                    |                         |      |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Python API           |                  |                    |                         |      |                  |
     | & REST API           | [2015-08-19 Wed] | [2015-08-26 Wed]   | 2                       |    6 |               12 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | VIEW -               |                  |                    | 4 till [2015-08-18 Tue] |    4 |               16 |
     | list, detail         | [2015-08-13 Thu] | [2015-08-26 Wed]   |                         |      |                  |
     | and update           |                  |                    |                         |      |                  |
     |                      |                  |                    | 2 till [2015-08-26 Wed] |    6 |               12 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Provisioning &       |                  |                    |                         |      |                  |
     | Data Model Evolution | [2015-08-19 Wed] | [2015-08-26 Wed]   | 1                       |    6 |                6 |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|
     | Filters              |                  |                    |                         |      |                  |
     |----------------------+------------------+--------------------+-------------------------+------+------------------|

*** Tasks & Deadlines
    1. Data Model
       + Completion Date :: [2015-08-18 Tue]
       + Effort :: 3 person days
       + Tasks
         - Describe each entity and capture the model of data for each entity.
         - Describe the relationship between all the entities.
    2. Python API , REST API and Migration scripts from old data to new model
       + Completion Data :: [2015-08-26 Wed]
       + Effort :: 12 person days
       + Tasks
         - Provide Python API to perform CRUD operations on different entities.
         - Provide REST API for different application to perform CRUD
           operations on different entities.
         - Provide a migration script that converts the legacy data into the
           new data model.
    3. VIEW - list, detail and update views of each entity
       + Completion Data :: [2015-08-26 Wed]
       + Effort :: 12 person days
       + Tasks
         - Provide a mechanism to list all the rows in an entity for all entities.
         - Provide a mechanism to a detailed view of a row in a selected entity.
         - Provide a mechanism to update a row in an entity.

    4. Filters

    5. Provisioning
